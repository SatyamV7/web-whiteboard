<!DOCTYPE html>
<html dir="ltr" lang="en">

<head>
  <meta charset="utf-8">
  <title>WebBoard</title>

  <meta name="viewport"
    content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Welcome to WebBoard!">
  <meta name="theme-color" content="#1976d2">

  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="WebBoard">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta http-equiv="x-ua-compatible" content="IE=Edge">

  <link rel="shortcut icon" href="/assets/icon/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icon/favicon.ico" type="image/x-icon">

  <link href="/build/app.css" rel="stylesheet">

  <!--<script src="https://unpkg.com/@microsoft/mgt/dist/bundle/mgt-loader.js"></script>-->

  <link rel="preconnect" href="https://static2.sharepointonline.com">

  <!--<script src="node_modules/@microsoft/mgt/dist/bundle/mgt-loader.js"></script>-->

  <script>
    window.requestIdleCallback =
      window.requestIdleCallback ||
      function (cb) {
        var start = Date.now();
        return setTimeout(function () {
          cb({
            didTimeout: false,
            timeRemaining: function () {
              return Math.max(0, 50 - (Date.now() - start));
            }
          });
        }, 1);
      }

    window.cancelIdleCallback =
      window.cancelIdleCallback ||
      function (id) {
        clearTimeout(id);
      }
  </script>


  <script>
    var mgt = function (e) {
      "use strict"; function _defineProperty(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function _getPrototypeOf(e) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function _get(e, t, r) { return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(e, t, r) { var n = function _superPropBase(e, t) { for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e));); return e }(e, t); if (n) { var o = Object.getOwnPropertyDescriptor(n, t); return o.get ? o.get.call(r) : o.value } })(e, t, r || e) } function _toArray(e) { return function _arrayWithHoles(e) { if (Array.isArray(e)) return e }(e) || function _iterableToArray(e) { if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e) }(e) || function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } function _toPropertyKey(e) { var t = function _toPrimitive(e, t) { if ("object" != typeof e || null === e) return e; var r = e[Symbol.toPrimitive]; if (void 0 !== r) { var n = r.call(e, t || "default"); if ("object" != typeof n) return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) } function _decorate(e, t, r, n) { var o = function _getDecoratorsApi() { (function () { return e }); var e = { elementsDefinitionOrder: [["method"], ["field"]], initializeInstanceElements: function (e, t) { ["method", "field"].forEach(function (r) { t.forEach(function (t) { t.kind === r && "own" === t.placement && this.defineClassElement(e, t) }, this) }, this) }, initializeClassElements: function (e, t) { var r = e.prototype;["method", "field"].forEach(function (n) { t.forEach(function (t) { var o = t.placement; if (t.kind === n && ("static" === o || "prototype" === o)) { var i = "static" === o ? e : r; this.defineClassElement(i, t) } }, this) }, this) }, defineClassElement: function (e, t) { var r = t.descriptor; if ("field" === t.kind) { var n = t.initializer; r = { enumerable: r.enumerable, writable: r.writable, configurable: r.configurable, value: void 0 === n ? void 0 : n.call(e) } } Object.defineProperty(e, t.key, r) }, decorateClass: function (e, t) { var r = [], n = [], o = { static: [], prototype: [], own: [] }; if (e.forEach(function (e) { this.addElementPlacement(e, o) }, this), e.forEach(function (e) { if (!_hasDecorators(e)) return r.push(e); var t = this.decorateElement(e, o); r.push(t.element), r.push.apply(r, t.extras), n.push.apply(n, t.finishers) }, this), !t) return { elements: r, finishers: n }; var i = this.decorateConstructor(r, t); return n.push.apply(n, i.finishers), i.finishers = n, i }, addElementPlacement: function (e, t, r) { var n = t[e.placement]; if (!r && -1 !== n.indexOf(e.key)) throw new TypeError("Duplicated element (" + e.key + ")"); n.push(e.key) }, decorateElement: function (e, t) { for (var r = [], n = [], o = e.decorators, i = o.length - 1; i >= 0; i--) { var s = t[e.placement]; s.splice(s.indexOf(e.key), 1); var a = this.fromElementDescriptor(e), c = this.toElementFinisherExtras((0, o[i])(a) || a); e = c.element, this.addElementPlacement(e, t), c.finisher && n.push(c.finisher); var l = c.extras; if (l) { for (var d = 0; d < l.length; d++)this.addElementPlacement(l[d], t); r.push.apply(r, l) } } return { element: e, finishers: n, extras: r } }, decorateConstructor: function (e, t) { for (var r = [], n = t.length - 1; n >= 0; n--) { var o = this.fromClassDescriptor(e), i = this.toClassDescriptor((0, t[n])(o) || o); if (void 0 !== i.finisher && r.push(i.finisher), void 0 !== i.elements) { e = i.elements; for (var s = 0; s < e.length - 1; s++)for (var a = s + 1; a < e.length; a++)if (e[s].key === e[a].key && e[s].placement === e[a].placement) throw new TypeError("Duplicated element (" + e[s].key + ")") } } return { elements: e, finishers: r } }, fromElementDescriptor: function (e) { var t = { kind: e.kind, key: e.key, placement: e.placement, descriptor: e.descriptor }; return Object.defineProperty(t, Symbol.toStringTag, { value: "Descriptor", configurable: !0 }), "field" === e.kind && (t.initializer = e.initializer), t }, toElementDescriptors: function (e) { if (void 0 !== e) return _toArray(e).map(function (e) { var t = this.toElementDescriptor(e); return this.disallowProperty(e, "finisher", "An element descriptor"), this.disallowProperty(e, "extras", "An element descriptor"), t }, this) }, toElementDescriptor: function (e) { var t = String(e.kind); if ("method" !== t && "field" !== t) throw new TypeError('An element descriptor\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "' + t + '"'); var r = _toPropertyKey(e.key), n = String(e.placement); if ("static" !== n && "prototype" !== n && "own" !== n) throw new TypeError('An element descriptor\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "' + n + '"'); var o = e.descriptor; this.disallowProperty(e, "elements", "An element descriptor"); var i = { kind: t, key: r, placement: n, descriptor: Object.assign({}, o) }; return "field" !== t ? this.disallowProperty(e, "initializer", "A method descriptor") : (this.disallowProperty(o, "get", "The property descriptor of a field descriptor"), this.disallowProperty(o, "set", "The property descriptor of a field descriptor"), this.disallowProperty(o, "value", "The property descriptor of a field descriptor"), i.initializer = e.initializer), i }, toElementFinisherExtras: function (e) { var t = this.toElementDescriptor(e), r = _optionalCallableProperty(e, "finisher"), n = this.toElementDescriptors(e.extras); return { element: t, finisher: r, extras: n } }, fromClassDescriptor: function (e) { var t = { kind: "class", elements: e.map(this.fromElementDescriptor, this) }; return Object.defineProperty(t, Symbol.toStringTag, { value: "Descriptor", configurable: !0 }), t }, toClassDescriptor: function (e) { var t = String(e.kind); if ("class" !== t) throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator created a class descriptor with .kind "' + t + '"'); this.disallowProperty(e, "key", "A class descriptor"), this.disallowProperty(e, "placement", "A class descriptor"), this.disallowProperty(e, "descriptor", "A class descriptor"), this.disallowProperty(e, "initializer", "A class descriptor"), this.disallowProperty(e, "extras", "A class descriptor"); var r = _optionalCallableProperty(e, "finisher"), n = this.toElementDescriptors(e.elements); return { elements: n, finisher: r } }, runClassFinishers: function (e, t) { for (var r = 0; r < t.length; r++) { var n = (0, t[r])(e); if (void 0 !== n) { if ("function" != typeof n) throw new TypeError("Finishers must return a constructor."); e = n } } return e }, disallowProperty: function (e, t, r) { if (void 0 !== e[t]) throw new TypeError(r + " can't have a ." + t + " property.") } }; return e }(); if (n) for (var i = 0; i < n.length; i++)o = n[i](o); var s = t(function initialize(e) { o.initializeInstanceElements(e, a.elements) }, r), a = o.decorateClass(function _coalesceClassElements(e) { for (var t = [], r = function (e) { return "method" === e.kind && e.key === i.key && e.placement === i.placement }, n = 0; n < e.length; n++) { var o, i = e[n]; if ("method" === i.kind && (o = t.find(r))) if (_isDataDescriptor(i.descriptor) || _isDataDescriptor(o.descriptor)) { if (_hasDecorators(i) || _hasDecorators(o)) throw new ReferenceError("Duplicated methods (" + i.key + ") can't be decorated."); o.descriptor = i.descriptor } else { if (_hasDecorators(i)) { if (_hasDecorators(o)) throw new ReferenceError("Decorators can't be placed on different accessors with for the same property (" + i.key + ")."); o.decorators = i.decorators } _coalesceGetterSetter(i, o) } else t.push(i) } return t }(s.d.map(_createElementDescriptor)), e); return o.initializeClassElements(s.F, a.elements), o.runClassFinishers(s.F, a.finishers) } function _createElementDescriptor(e) { var t, r = _toPropertyKey(e.key); "method" === e.kind ? t = { value: e.value, writable: !0, configurable: !0, enumerable: !1 } : "get" === e.kind ? t = { get: e.value, configurable: !0, enumerable: !1 } : "set" === e.kind ? t = { set: e.value, configurable: !0, enumerable: !1 } : "field" === e.kind && (t = { configurable: !0, writable: !0, enumerable: !0 }); var n = { kind: "field" === e.kind ? "field" : "method", key: r, placement: e.static ? "static" : "field" === e.kind ? "own" : "prototype", descriptor: t }; return e.decorators && (n.decorators = e.decorators), "field" === e.kind && (n.initializer = e.value), n } function _coalesceGetterSetter(e, t) { void 0 !== e.descriptor.get ? t.descriptor.get = e.descriptor.get : t.descriptor.set = e.descriptor.set } function _hasDecorators(e) { return e.decorators && e.decorators.length } function _isDataDescriptor(e) { return void 0 !== e && !(void 0 === e.value && void 0 === e.writable) } function _optionalCallableProperty(e, t) { var r = e[t]; if (void 0 !== r && "function" != typeof r) throw new TypeError("Expected '" + t + "' to be a function"); return r } const t = new WeakMap, r = e => (...r) => { const n = e(...r); return t.set(n, !0), n }, n = e => "function" == typeof e && t.has(e), o = void 0 !== window.customElements && void 0 !== window.customElements.polyfillWrapFlushCallback, i = (e, t, r = null) => { let n = t; for (; n !== r;) { const t = n.nextSibling; e.removeChild(n), n = t } }, s = {}, a = {}, c = `{{lit-${String(Math.random()).slice(2)}}}`, l = `\x3c!--${c}--\x3e`, d = new RegExp(`${c}|${l}`), u = "$lit$"; class Template { constructor(e, t) { this.parts = [], this.element = t; let r = -1, n = 0; const o = [], i = t => { const s = t.content, a = document.createTreeWalker(s, 133, null, !1); let l = 0; for (; a.nextNode();) { r++; const t = a.currentNode; if (1 === t.nodeType) { if (t.hasAttributes()) { const o = t.attributes; let i = 0; for (let e = 0; e < o.length; e++)o[e].value.indexOf(c) >= 0 && i++; for (; i-- > 0;) { const o = e.strings[n], i = g.exec(o)[2], s = i.toLowerCase() + u, a = t.getAttribute(s).split(d); this.parts.push({ type: "attribute", index: r, name: i, strings: a }), t.removeAttribute(s), n += a.length - 1 } } "TEMPLATE" === t.tagName && i(t) } else if (3 === t.nodeType) { const e = t.data; if (e.indexOf(c) >= 0) { const i = t.parentNode, s = e.split(d), a = s.length - 1; for (let e = 0; e < a; e++)i.insertBefore("" === s[e] ? p() : document.createTextNode(s[e]), t), this.parts.push({ type: "node", index: ++r }); "" === s[a] ? (i.insertBefore(p(), t), o.push(t)) : t.data = s[a], n += a } } else if (8 === t.nodeType) if (t.data === c) { const e = t.parentNode; null !== t.previousSibling && r !== l || (r++ , e.insertBefore(p(), t)), l = r, this.parts.push({ type: "node", index: r }), null === t.nextSibling ? t.data = "" : (o.push(t), r--), n++ } else { let e = -1; for (; -1 !== (e = t.data.indexOf(c, e + 1));)this.parts.push({ type: "node", index: -1 }) } } }; i(t); for (const e of o) e.parentNode.removeChild(e) } } const h = e => -1 !== e.index, p = () => document.createComment(""), g = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=\/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/; class TemplateInstance { constructor(e, t, r) { this._parts = [], this.template = e, this.processor = t, this.options = r } update(e) { let t = 0; for (const r of this._parts) void 0 !== r && r.setValue(e[t]), t++; for (const e of this._parts) void 0 !== e && e.commit() } _clone() { const e = o ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0), t = this.template.parts; let r = 0, n = 0; const i = e => { const o = document.createTreeWalker(e, 133, null, !1); let s = o.nextNode(); for (; r < t.length && null !== s;) { const e = t[r]; if (h(e)) if (n === e.index) { if ("node" === e.type) { const e = this.processor.handleTextExpression(this.options); e.insertAfterNode(s.previousSibling), this._parts.push(e) } else this._parts.push(...this.processor.handleAttributeExpressions(s, e.name, e.strings, this.options)); r++ } else n++ , "TEMPLATE" === s.nodeName && i(s.content), s = o.nextNode(); else this._parts.push(void 0), r++ } }; return i(e), o && (document.adoptNode(e), customElements.upgrade(e)), e } } class TemplateResult { constructor(e, t, r, n) { this.strings = e, this.values = t, this.type = r, this.processor = n } getHTML() { const e = this.strings.length - 1; let t = ""; for (let r = 0; r < e; r++) { const e = this.strings[r], n = g.exec(e); t += n ? e.substr(0, n.index) + n[1] + n[2] + u + n[3] + c : e + l } return t + this.strings[e] } getTemplateElement() { const e = document.createElement("template"); return e.innerHTML = this.getHTML(), e } } const f = e => null === e || !("object" == typeof e || "function" == typeof e); class AttributeCommitter { constructor(e, t, r) { this.dirty = !0, this.element = e, this.name = t, this.strings = r, this.parts = []; for (let e = 0; e < r.length - 1; e++)this.parts[e] = this._createPart() } _createPart() { return new AttributePart(this) } _getValue() { const e = this.strings, t = e.length - 1; let r = ""; for (let n = 0; n < t; n++) { r += e[n]; const t = this.parts[n]; if (void 0 !== t) { const e = t.value; if (null != e && (Array.isArray(e) || "string" != typeof e && e[Symbol.iterator])) for (const t of e) r += "string" == typeof t ? t : String(t); else r += "string" == typeof e ? e : String(e) } } return r += e[t] } commit() { this.dirty && (this.dirty = !1, this.element.setAttribute(this.name, this._getValue())) } } class AttributePart { constructor(e) { this.value = void 0, this.committer = e } setValue(e) { e === s || f(e) && e === this.value || (this.value = e, n(e) || (this.committer.dirty = !0)) } commit() { for (; n(this.value);) { const e = this.value; this.value = s, e(this) } this.value !== s && this.committer.commit() } } class NodePart { constructor(e) { this.value = void 0, this._pendingValue = void 0, this.options = e } appendInto(e) { this.startNode = e.appendChild(p()), this.endNode = e.appendChild(p()) } insertAfterNode(e) { this.startNode = e, this.endNode = e.nextSibling } appendIntoPart(e) { e._insert(this.startNode = p()), e._insert(this.endNode = p()) } insertAfterPart(e) { e._insert(this.startNode = p()), this.endNode = e.endNode, e.endNode = this.startNode } setValue(e) { this._pendingValue = e } commit() { for (; n(this._pendingValue);) { const e = this._pendingValue; this._pendingValue = s, e(this) } const e = this._pendingValue; e !== s && (f(e) ? e !== this.value && this._commitText(e) : e instanceof TemplateResult ? this._commitTemplateResult(e) : e instanceof Node ? this._commitNode(e) : Array.isArray(e) || e[Symbol.iterator] ? this._commitIterable(e) : e === a ? (this.value = a, this.clear()) : this._commitText(e)) } _insert(e) { this.endNode.parentNode.insertBefore(e, this.endNode) } _commitNode(e) { this.value !== e && (this.clear(), this._insert(e), this.value = e) } _commitText(e) { const t = this.startNode.nextSibling; e = null == e ? "" : e, t === this.endNode.previousSibling && 3 === t.nodeType ? t.data = e : this._commitNode(document.createTextNode("string" == typeof e ? e : String(e))), this.value = e } _commitTemplateResult(e) { const t = this.options.templateFactory(e); if (this.value instanceof TemplateInstance && this.value.template === t) this.value.update(e.values); else { const r = new TemplateInstance(t, e.processor, this.options), n = r._clone(); r.update(e.values), this._commitNode(n), this.value = r } } _commitIterable(e) { Array.isArray(this.value) || (this.value = [], this.clear()); const t = this.value; let r, n = 0; for (const o of e) void 0 === (r = t[n]) && (r = new NodePart(this.options), t.push(r), 0 === n ? r.appendIntoPart(this) : r.insertAfterPart(t[n - 1])), r.setValue(o), r.commit(), n++; n < t.length && (t.length = n, this.clear(r && r.endNode)) } clear(e = this.startNode) { i(this.startNode.parentNode, e.nextSibling, this.endNode) } } class BooleanAttributePart { constructor(e, t, r) { if (this.value = void 0, this._pendingValue = void 0, 2 !== r.length || "" !== r[0] || "" !== r[1]) throw new Error("Boolean attributes can only contain a single expression"); this.element = e, this.name = t, this.strings = r } setValue(e) { this._pendingValue = e } commit() { for (; n(this._pendingValue);) { const e = this._pendingValue; this._pendingValue = s, e(this) } if (this._pendingValue === s) return; const e = !!this._pendingValue; this.value !== e && (e ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name)), this.value = e, this._pendingValue = s } } class PropertyCommitter extends AttributeCommitter { constructor(e, t, r) { super(e, t, r), this.single = 2 === r.length && "" === r[0] && "" === r[1] } _createPart() { return new PropertyPart(this) } _getValue() { return this.single ? this.parts[0].value : super._getValue() } commit() { this.dirty && (this.dirty = !1, this.element[this.name] = this._getValue()) } } class PropertyPart extends AttributePart { } let m = !1; try { const e = { get capture() { return m = !0, !1 } }; window.addEventListener("test", e, e), window.removeEventListener("test", e, e) } catch (e) { } class EventPart { constructor(e, t, r) { this.value = void 0, this._pendingValue = void 0, this.element = e, this.eventName = t, this.eventContext = r, this._boundHandleEvent = (e => this.handleEvent(e)) } setValue(e) { this._pendingValue = e } commit() { for (; n(this._pendingValue);) { const e = this._pendingValue; this._pendingValue = s, e(this) } if (this._pendingValue === s) return; const e = this._pendingValue, t = this.value, r = null == e || null != t && (e.capture !== t.capture || e.once !== t.once || e.passive !== t.passive), o = null != e && (null == t || r); r && this.element.removeEventListener(this.eventName, this._boundHandleEvent, this._options), o && (this._options = y(e), this.element.addEventListener(this.eventName, this._boundHandleEvent, this._options)), this.value = e, this._pendingValue = s } handleEvent(e) { "function" == typeof this.value ? this.value.call(this.eventContext || this.element, e) : this.value.handleEvent(e) } } const y = e => e && (m ? { capture: e.capture, passive: e.passive, once: e.once } : e.capture); const k = new class DefaultTemplateProcessor { handleAttributeExpressions(e, t, r, n) { const o = t[0]; return "." === o ? new PropertyCommitter(e, t.slice(1), r).parts : "@" === o ? [new EventPart(e, t.slice(1), n.eventContext)] : "?" === o ? [new BooleanAttributePart(e, t.slice(1), r)] : new AttributeCommitter(e, t, r).parts } handleTextExpression(e) { return new NodePart(e) } }; function templateFactory(e) { let t = v.get(e.type); void 0 === t && (t = { stringsArray: new WeakMap, keyString: new Map }, v.set(e.type, t)); let r = t.stringsArray.get(e.strings); if (void 0 !== r) return r; const n = e.strings.join(c); return void 0 === (r = t.keyString.get(n)) && (r = new Template(e, e.getTemplateElement()), t.keyString.set(n, r)), t.stringsArray.set(e.strings, r), r } const v = new Map, w = new WeakMap; (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.0.0"); const T = (e, ...t) => new TemplateResult(e, t, "html", k), S = 133; function removeNodesFromTemplate(e, t) { const { element: { content: r }, parts: n } = e, o = document.createTreeWalker(r, S, null, !1); let i = _(n), s = n[i], a = -1, c = 0; const l = []; let d = null; for (; o.nextNode();) { a++; const e = o.currentNode; for (e.previousSibling === d && (d = null), t.has(e) && (l.push(e), null === d && (d = e)), null !== d && c++; void 0 !== s && s.index === a;)s.index = null !== d ? -1 : s.index - c, s = n[i = _(n, i)] } l.forEach(e => e.parentNode.removeChild(e)) } const b = e => { let t = 11 === e.nodeType ? 0 : 1; const r = document.createTreeWalker(e, S, null, !1); for (; r.nextNode();)t++; return t }, _ = (e, t = -1) => { for (let r = t + 1; r < e.length; r++) { const t = e[r]; if (h(t)) return r } return -1 }; const A = (e, t) => `${e}--${t}`; let C = !0; void 0 === window.ShadyCSS ? C = !1 : void 0 === window.ShadyCSS.prepareTemplateDom && (console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."), C = !1); const I = e => t => { const r = A(t.type, e); let n = v.get(r); void 0 === n && (n = { stringsArray: new WeakMap, keyString: new Map }, v.set(r, n)); let o = n.stringsArray.get(t.strings); if (void 0 !== o) return o; const i = t.strings.join(c); if (void 0 === (o = n.keyString.get(i))) { const r = t.getTemplateElement(); C && window.ShadyCSS.prepareTemplateDom(r, e), o = new Template(t, r), n.keyString.set(i, o) } return n.stringsArray.set(t.strings, o), o }, E = ["html", "svg"], P = new Set, x = (e, t, r) => { P.add(r); const n = e.querySelectorAll("style"); if (0 === n.length) return void window.ShadyCSS.prepareTemplateStyles(t.element, r); const o = document.createElement("style"); for (let e = 0; e < n.length; e++) { const t = n[e]; t.parentNode.removeChild(t), o.textContent += t.textContent } if ((e => { E.forEach(t => { const r = v.get(A(t, e)); void 0 !== r && r.keyString.forEach(e => { const { element: { content: t } } = e, r = new Set; Array.from(t.querySelectorAll("style")).forEach(e => { r.add(e) }), removeNodesFromTemplate(e, r) }) }) })(r), function insertNodeIntoTemplate(e, t, r = null) { const { element: { content: n }, parts: o } = e; if (null == r) return void n.appendChild(t); const i = document.createTreeWalker(n, S, null, !1); let s = _(o), a = 0, c = -1; for (; i.nextNode();)for (c++ , i.currentNode === r && (a = b(t), r.parentNode.insertBefore(t, r)); -1 !== s && o[s].index === c;) { if (a > 0) { for (; -1 !== s;)o[s].index += a, s = _(o, s); return } s = _(o, s) } }(t, o, t.element.content.firstChild), window.ShadyCSS.prepareTemplateStyles(t.element, r), window.ShadyCSS.nativeShadow) { const r = t.element.content.querySelector("style"); e.insertBefore(r.cloneNode(!0), e.firstChild) } else { t.element.content.insertBefore(o, t.element.content.firstChild); const e = new Set; e.add(o), removeNodesFromTemplate(t, e) } }; window.JSCompiler_renameProperty = ((e, t) => e); const D = { toAttribute(e, t) { switch (t) { case Boolean: return e ? "" : null; case Object: case Array: return null == e ? e : JSON.stringify(e) }return e }, fromAttribute(e, t) { switch (t) { case Boolean: return null !== e; case Number: return null === e ? null : Number(e); case Object: case Array: return JSON.parse(e) }return e } }, R = (e, t) => t !== e && (t == t || e == e), O = { attribute: !0, type: String, converter: D, reflect: !1, hasChanged: R }, U = Promise.resolve(!0), N = 1, M = 4, L = 8, H = 16, F = 32; class UpdatingElement extends HTMLElement { constructor() { super(), this._updateState = 0, this._instanceProperties = void 0, this._updatePromise = U, this._hasConnectedResolver = void 0, this._changedProperties = new Map, this._reflectingProperties = void 0, this.initialize() } static get observedAttributes() { this.finalize(); const e = []; return this._classProperties.forEach((t, r) => { const n = this._attributeNameForProperty(r, t); void 0 !== n && (this._attributeToPropertyMap.set(n, r), e.push(n)) }), e } static _ensureClassProperties() { if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) { this._classProperties = new Map; const e = Object.getPrototypeOf(this)._classProperties; void 0 !== e && e.forEach((e, t) => this._classProperties.set(t, e)) } } static createProperty(e, t = O) { if (this._ensureClassProperties(), this._classProperties.set(e, t), t.noAccessor || this.prototype.hasOwnProperty(e)) return; const r = "symbol" == typeof e ? Symbol() : `__${e}`; Object.defineProperty(this.prototype, e, { get() { return this[r] }, set(t) { const n = this[e]; this[r] = t, this._requestUpdate(e, n) }, configurable: !0, enumerable: !0 }) } static finalize() { if (this.hasOwnProperty(JSCompiler_renameProperty("finalized", this)) && this.finalized) return; const e = Object.getPrototypeOf(this); if ("function" == typeof e.finalize && e.finalize(), this.finalized = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map, this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) { const e = this.properties, t = [...Object.getOwnPropertyNames(e), ..."function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : []]; for (const r of t) this.createProperty(r, e[r]) } } static _attributeNameForProperty(e, t) { const r = t.attribute; return !1 === r ? void 0 : "string" == typeof r ? r : "string" == typeof e ? e.toLowerCase() : void 0 } static _valueHasChanged(e, t, r = R) { return r(e, t) } static _propertyValueFromAttribute(e, t) { const r = t.type, n = t.converter || D, o = "function" == typeof n ? n : n.fromAttribute; return o ? o(e, r) : e } static _propertyValueToAttribute(e, t) { if (void 0 === t.reflect) return; const r = t.type, n = t.converter; return (n && n.toAttribute || D.toAttribute)(e, r) } initialize() { this._saveInstanceProperties(), this._requestUpdate() } _saveInstanceProperties() { this.constructor._classProperties.forEach((e, t) => { if (this.hasOwnProperty(t)) { const e = this[t]; delete this[t], this._instanceProperties || (this._instanceProperties = new Map), this._instanceProperties.set(t, e) } }) } _applyInstanceProperties() { this._instanceProperties.forEach((e, t) => this[t] = e), this._instanceProperties = void 0 } connectedCallback() { this._updateState = this._updateState | F, this._hasConnectedResolver && (this._hasConnectedResolver(), this._hasConnectedResolver = void 0) } disconnectedCallback() { } attributeChangedCallback(e, t, r) { t !== r && this._attributeToProperty(e, r) } _propertyToAttribute(e, t, r = O) { const n = this.constructor, o = n._attributeNameForProperty(e, r); if (void 0 !== o) { const e = n._propertyValueToAttribute(t, r); if (void 0 === e) return; this._updateState = this._updateState | L, null == e ? this.removeAttribute(o) : this.setAttribute(o, e), this._updateState = this._updateState & ~L } } _attributeToProperty(e, t) { if (this._updateState & L) return; const r = this.constructor, n = r._attributeToPropertyMap.get(e); if (void 0 !== n) { const e = r._classProperties.get(n) || O; this._updateState = this._updateState | H, this[n] = r._propertyValueFromAttribute(t, e), this._updateState = this._updateState & ~H } } _requestUpdate(e, t) { let r = !0; if (void 0 !== e) { const n = this.constructor, o = n._classProperties.get(e) || O; n._valueHasChanged(this[e], t, o.hasChanged) ? (this._changedProperties.has(e) || this._changedProperties.set(e, t), !0 !== o.reflect || this._updateState & H || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map), this._reflectingProperties.set(e, o))) : r = !1 } !this._hasRequestedUpdate && r && this._enqueueUpdate() } requestUpdate(e, t) { return this._requestUpdate(e, t), this.updateComplete } async _enqueueUpdate() { let e, t; this._updateState = this._updateState | M; const r = this._updatePromise; this._updatePromise = new Promise((r, n) => { e = r, t = n }); try { await r } catch (e) { } this._hasConnected || await new Promise(e => this._hasConnectedResolver = e); try { const e = this.performUpdate(); null != e && await e } catch (e) { t(e) } e(!this._hasRequestedUpdate) } get _hasConnected() { return this._updateState & F } get _hasRequestedUpdate() { return this._updateState & M } get hasUpdated() { return this._updateState & N } performUpdate() { this._instanceProperties && this._applyInstanceProperties(); let e = !1; const t = this._changedProperties; try { (e = this.shouldUpdate(t)) && this.update(t) } catch (t) { throw e = !1, t } finally { this._markUpdated() } e && (this._updateState & N || (this._updateState = this._updateState | N, this.firstUpdated(t)), this.updated(t)) } _markUpdated() { this._changedProperties = new Map, this._updateState = this._updateState & ~M } get updateComplete() { return this._updatePromise } shouldUpdate(e) { return !0 } update(e) { void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach((e, t) => this._propertyToAttribute(t, this[t], e)), this._reflectingProperties = void 0) } updated(e) { } firstUpdated(e) { } } UpdatingElement.finalized = !0; const q = e => t => "function" == typeof t ? ((e, t) => (window.customElements.define(e, t), t))(e, t) : ((e, t) => { const { kind: r, elements: n } = t; return { kind: r, elements: n, finisher(t) { window.customElements.define(e, t) } } })(e, t), j = (e, t) => "method" !== t.kind || !t.descriptor || "value" in t.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, initializer() { "function" == typeof t.initializer && (this[t.key] = t.initializer.call(this)) }, finisher(r) { r.createProperty(t.key, e) } } : Object.assign({}, t, { finisher(r) { r.createProperty(t.key, e) } }), $ = (e, t, r) => { t.constructor.createProperty(r, e) }; function property(e) { return (t, r) => void 0 !== r ? $(e, t, r) : j(e, t) } const B = "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, V = Symbol(); class CSSResult { constructor(e, t) { if (t !== V) throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead."); this.cssText = e } get styleSheet() { return void 0 === this._styleSheet && (B ? (this._styleSheet = new CSSStyleSheet, this._styleSheet.replaceSync(this.cssText)) : this._styleSheet = null), this._styleSheet } toString() { return this.cssText } } const z = (e, ...t) => { const r = t.reduce((t, r, n) => t + (e => { if (e instanceof CSSResult) return e.cssText; throw new Error(`Value passed to 'css' function must be a 'css' function result: ${e}. Use 'unsafeCSS' to pass non-literal values, but\n            take care to ensure page security.`) })(r) + e[n + 1], e[0]); return new CSSResult(r, V) }; (window.litElementVersions || (window.litElementVersions = [])).push("2.0.1"); const G = e => e.flat ? e.flat(1 / 0) : function arrayFlat(e, t = []) { for (let r = 0, n = e.length; r < n; r++) { const n = e[r]; Array.isArray(n) ? arrayFlat(n, t) : t.push(n) } return t }(e); class LitElement extends UpdatingElement { static finalize() { super.finalize(), this._styles = this.hasOwnProperty(JSCompiler_renameProperty("styles", this)) ? this._getUniqueStyles() : this._styles || [] } static _getUniqueStyles() { const e = this.styles, t = []; if (Array.isArray(e)) { G(e).reduceRight((e, t) => (e.add(t), e), new Set).forEach(e => t.unshift(e)) } else e && t.push(e); return t } initialize() { super.initialize(), this.renderRoot = this.createRenderRoot(), window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles() } createRenderRoot() { return this.attachShadow({ mode: "open" }) } adoptStyles() { const e = this.constructor._styles; 0 !== e.length && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow ? B ? this.renderRoot.adoptedStyleSheets = e.map(e => e.styleSheet) : this._needsShimAdoptedStyleSheets = !0 : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e => e.cssText), this.localName)) } connectedCallback() { super.connectedCallback(), this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this) } update(e) { super.update(e); const t = this.render(); t instanceof TemplateResult && this.constructor.render(t, this.renderRoot, { scopeName: this.localName, eventContext: this }), this._needsShimAdoptedStyleSheets && (this._needsShimAdoptedStyleSheets = !1, this.constructor._styles.forEach(e => { const t = document.createElement("style"); t.textContent = e.cssText, this.renderRoot.appendChild(t) })) } render() { } } LitElement.finalized = !0, LitElement.render = ((e, t, r) => { const n = r.scopeName, o = w.has(t), s = t instanceof ShadowRoot && C && e instanceof TemplateResult, a = s && !P.has(n), c = a ? document.createDocumentFragment() : t; if (((e, t, r) => { let n = w.get(t); void 0 === n && (i(t, t.firstChild), w.set(t, n = new NodePart(Object.assign({ templateFactory: templateFactory }, r))), n.appendInto(t)), n.setValue(e), n.commit() })(e, c, Object.assign({ templateFactory: I(n) }, r)), a) { const e = w.get(c); w.delete(c), e.value instanceof TemplateInstance && x(c, e.value.template, n), i(t, t.firstChild), t.appendChild(c), w.set(t, e) } !o && s && window.ShadyCSS.styleElement(t.host) }); class IProvider { get state() { return this._state } setState(e) { e != this._state && (this._state = e, this._loginChangedDispatcher.fire({})) } onStateChanged(e) { this._loginChangedDispatcher.add(e) } removeStateChangedHandler(e) { this._loginChangedDispatcher.remove(e) } constructor() { _defineProperty(this, "_state", void 0), _defineProperty(this, "_loginChangedDispatcher", new EventDispatcher), _defineProperty(this, "graph", void 0), this._state = e.ProviderState.Loading } getAccessTokenForScopes(...e) { return this.getAccessToken({ scopes: e }) } } class EventDispatcher { constructor() { _defineProperty(this, "eventHandlers", []) } fire(e) { for (let t of this.eventHandlers) t(e) } add(e) { this.eventHandlers.push(e) } remove(e) { for (let t = 0; t < this.eventHandlers.length; t++)this.eventHandlers[t] === e && (this.eventHandlers.splice(t, 1), t--) } } var W, Q, J; (W = e.LoginType || (e.LoginType = {}))[W.Popup = 0] = "Popup", W[W.Redirect = 1] = "Redirect", (Q = e.ProviderState || (e.ProviderState = {}))[Q.Loading = 0] = "Loading", Q[Q.SignedOut = 1] = "SignedOut", Q[Q.SignedIn = 2] = "SignedIn"; class Providers { static get globalProvider() { return this._globalProvider } static set globalProvider(t) { t !== this._globalProvider && (this._globalProvider && this._globalProvider.removeStateChangedHandler(this.handleProviderStateChanged), t && t.onStateChanged(this.handleProviderStateChanged), this._globalProvider = t, this._eventDispatcher.fire(e.ProvidersChangedState.ProviderChanged)) } static onProviderUpdated(e) { this._eventDispatcher.add(e) } static removeProviderUpdatedListener(e) { this._eventDispatcher.remove(e) } static handleProviderStateChanged() { Providers._eventDispatcher.fire(e.ProvidersChangedState.ProviderStateChanged) } } _defineProperty(Providers, "_eventDispatcher", new EventDispatcher), _defineProperty(Providers, "_globalProvider", void 0), (J = e.ProvidersChangedState || (e.ProvidersChangedState = {}))[J.ProviderChanged = 0] = "ProviderChanged", J[J.ProviderStateChanged = 1] = "ProviderStateChanged"; class MgtBaseComponent extends LitElement { fireCustomEvent(e, t) { let r = new CustomEvent(e, { cancelable: !0, bubbles: !1, detail: t }); return this.dispatchEvent(r) } static get useShadowRoot() { return this._useShadowRoot } static set useShadowRoot(e) { this._useShadowRoot = e } constructor() { super(), this.isShadowRootDisabled() && (this._needsShimAdoptedStyleSheets = !0) } createRenderRoot() { return this.isShadowRootDisabled() ? this : super.createRenderRoot() } isShadowRootDisabled() { return !MgtBaseComponent._useShadowRoot || !this.constructor._useShadowRoot } } _defineProperty(MgtBaseComponent, "_useShadowRoot", !0); const K = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

:host,
mgt-login {
  --font-size: 14px;
  --font-weight: 600;
  --height: '100%';
  --margin: 0;
  --padding: 12px 20px;
  --color: #201f1e;
  --background-color: transparent;
  --background-color--hover: #edebe9;
  --popup-content-background-color: white;
  --popup-command-font-size: 12px; }

:host .root,
mgt-login .root {
  position: relative;
  display: inline-block; }

:host .login-button,
mgt-login .login-button {
  display: flex;
  align-items: center;
  font-family: var(--default-font-family);
  font-size: var(--font-size);
  font-weight: var(--font-weight);
  height: var(--height);
  margin: var(--margin);
  padding: var(--padding);
  color: var(--color);
  background-color: var(--background-color);
  border: none;
  cursor: pointer;
  transition: color 0.3s, background-color 0.3s; }
  :host .login-button:hover,
  mgt-login .login-button:hover {
    color: var(--theme-primary-color);
    background-color: var(--background-color--hover); }
  :host .login-button:focus,
  mgt-login .login-button:focus {
    outline: 0; }
  :host .login-button:disabled,
  mgt-login .login-button:disabled {
    opacity: 0.4;
    pointer-events: none; }

:host .login-icon + span,
mgt-login .login-icon + span {
  margin-left: 6px; }

:host .popup,
mgt-login .popup {
  display: none;
  position: absolute;
  animation-duration: 300ms;
  font-family: var(--default-font-family);
  background: var(--popup-content-background-color);
  box-shadow: 0 12px 40px 2px rgba(0, 0, 0, 0.08);
  min-width: 240px;
  z-index: 1; }
  :host .popup.show-menu,
  mgt-login .popup.show-menu {
    display: inline-block;
    animation-name: fade-in; }
  :host .popup.open-left,
  mgt-login .popup.open-left {
    right: 0; }

:host .popup-content,
mgt-login .popup-content {
  display: flex;
  flex-direction: column;
  padding: 24px 48px 16px 24px; }

:host .popup-commands ul,
mgt-login .popup-commands ul {
  list-style-type: none;
  margin: 16px 0 0;
  padding: 0; }

:host .popup-command,
mgt-login .popup-command {
  font-family: var(--default-font-family);
  font-size: var(--popup-command-font-size);
  font-weight: var(--font-weight);
  color: var(--theme-primary-color);
  background-color: transparent;
  border: none;
  padding: 0;
  cursor: pointer;
  transition: color 0.3s; }
  :host .popup-command:hover,
  mgt-login .popup-command:hover {
    color: var(--theme-dark-color); }

@keyframes fade-in {
  from {
    opacity: 0; }
  to {
    opacity: 1; } }

`], X = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

:host svg,
mgt-person svg {
  width: var(--avatar-size-s, 24px);
  height: var(--avatar-size-s, 24px); }

:host img,
mgt-person img {
  border: var(--avatar-border);
  border-radius: 50%; }

:host .root,
mgt-person .root {
  position: relative;
  display: flex;
  align-items: center;
  font-family: var(--default-font-family, "Segoe UI"); }

:host .Details,
mgt-person .Details {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  margin-left: 12px; }
  :host .Details.small,
  mgt-person .Details.small {
    margin-left: 6px; }

:host .user-avatar,
mgt-person .user-avatar {
  width: var(--avatar-size, 48px);
  height: var(--avatar-size, 48px); }
  :host .user-avatar.initials,
  mgt-person .user-avatar.initials {
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--initials-color, white);
    background-color: var(--initials-background-color, #b4009e);
    border-radius: 50%;
    font-weight: 400;
    font-size: 60%; }
  :host .user-avatar.small,
  mgt-person .user-avatar.small {
    width: var(--avatar-size-s, 24px);
    height: var(--avatar-size-s, 24px); }
  :host .user-avatar.row-span-2,
  mgt-person .user-avatar.row-span-2 {
    width: var(--avatar-size, 48px);
    height: var(--avatar-size, 48px); }
  :host .user-avatar.row-span-3,
  mgt-person .user-avatar.row-span-3 {
    width: var(--avatar-size, 48px);
    height: var(--avatar-size, 48px); }

:host .avatar-icon,
mgt-person .avatar-icon {
  flex: 1 1 auto;
  font-size: var(--avatar-font-size, 32px); }
  :host .avatar-icon.small,
  mgt-person .avatar-icon.small {
    font-size: var(--avatar-font-size--s, 16px); }
  :host .avatar-icon.row-span-2,
  mgt-person .avatar-icon.row-span-2 {
    grid-row: 1 / 3;
    -ms-grid-row: 1;
    -ms-grid-row-span: 2; }
  :host .avatar-icon.row-span-3,
  mgt-person .avatar-icon.row-span-3 {
    grid-row: 1 / 4;
    -ms-grid-row: 1;
    -ms-grid-row-span: 3; }

:host .user-name,
mgt-person .user-name {
  font-size: var(--font-size, 14px);
  font-weight: var(--font-weight, 600);
  white-space: nowrap;
  grid-column: 2;
  -ms-grid-column: 2; }

:host .user-email,
mgt-person .user-email {
  color: var(--email-color, #323130);
  font-size: var(--email-font-size, 12px);
  white-space: nowrap;
  grid-column: 2;
  -ms-grid-column: 2;
  grid-row: 2;
  -ms-grid-row: 2; }

`], Z = document.createElement("style"); Z.type = "text/css", Z.appendChild(document.createTextNode("\n@font-face {\n    font-family: 'FabricMDL2Icons';\n    src: url('https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.woff2') format('woff2'),\n    url(https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.woff) format(\"woff\"),\n    url(https://static2.sharepointonline.com/files/fabric/assets/icons/fabricmdl2icons-2.68.ttf) format(\"truetype\");;\n}\n")), document.head.appendChild(Z); class TemplateHelper { static getValueFromObject(e, t) { let r = t.trim().split("."), n = e; for (let e = 0; e < r.length; e++) { if (!(n = n[r[e]])) return null } return n } static replaceExpression(e, t) { return e.replace(this._expression, e => { let r = e.substring(2, e.length - 2), n = this.getValueFromObject(t, r); return n ? "object" == typeof n ? JSON.stringify(n) : n.toString() : "" }) } static renderNode(e, t) { if ("#text" === e.nodeName) return e.textContent = this.replaceExpression(e.textContent, t), e; let r = e; if (r.attributes) for (let e = 0; e < r.attributes.length; e++) { let n = r.attributes[e]; r.setAttribute(n.name, this.replaceExpression(n.value, t)) } let n = [], o = [], i = !1; for (let r = 0; r < e.childNodes.length; r++) { let s = e.childNodes[r], a = s, c = !1; if (a.dataset) { let e = !1; if (a.dataset.if) { let r = a.dataset.if; this.evalInContext(r, t) ? (a.removeAttribute("data-if"), i = !0, c = !0) : (o.push(a), e = !0) } else void 0 !== a.dataset.else && (i ? (o.push(a), e = !0) : a.removeAttribute("data-else")); a.dataset.for && !e ? n.push(a) : e || this.renderNode(s, t) } else this.renderNode(s, t); c || "#text" === s.nodeName || (i = !1) } for (let e = 0; e < o.length; e++)r.removeChild(o[e]); for (let e = 0; e < n.length; e++) { let o = n[e], i = o.dataset.for.split(" "); if (i.length > 1) { let e = i[0], n = i[i.length - 1], s = this.getValueFromObject(t, n); if (Array.isArray(s)) { r.removeChild(o), o.removeAttribute("data-for"); for (let t = 0; t < s.length; t++) { let n = {}; n[e] = s[t], n.index = t; let i = o.cloneNode(!0); this.renderNode(i, n), r.appendChild(i) } } } } return e } static evalInContext(e, t) { return new Function("with(this) { return !!(" + e + ")}").call(t) } static renderTemplate(e, t) { if (e.content && e.content.childNodes.length) { let r = e.content.cloneNode(!0); return this.renderNode(r, t) } if (e.childNodes.length) { let r = document.createElement("div"); for (let t = 0; t < e.childNodes.length; t++)r.appendChild(e.childNodes[t].cloneNode(!0)); return this.renderNode(r, t) } } } _defineProperty(TemplateHelper, "_expression", /{{\s*[\w\.]+\s*}}/g); class MgtTemplatedComponent extends MgtBaseComponent {
        constructor(...e) { super(...e), _defineProperty(this, "_renderedSlots", !1), _defineProperty(this, "_slotNamesAddedDuringRender", []), _defineProperty(this, "templates", {}) } update(e) { this.templates = this.getTemplates(), this._slotNamesAddedDuringRender = [], super.update(e) } updated() { this.removeUnusedSlottedElements() } getTemplates() { let e = {}; for (let t = 0; t < this.children.length; t++) { let r = this.children[t]; if ("TEMPLATE" == r.nodeName) { let t = r; t.dataset.type ? e[t.dataset.type] = t : e.default = t } } return e } removeUnusedSlottedElements() { if (this._renderedSlots) { for (let e = 0; e < this.children.length; e++) { let t = this.children[e]; t.dataset && t.dataset.generated && !this._slotNamesAddedDuringRender.includes(t.slot) && (this.removeChild(t), e--) } this._renderedSlots = !1 } } renderTemplate(e, t, r) {
          if (!this.templates[e]) return null; r = r || e, this._slotNamesAddedDuringRender.push(r), this._renderedSlots = !0; for (let e = 0; e < this.children.length; e++)if (this.children[e].slot == r) return T`
          <slot name=${r}></slot>
        `; let n = TemplateHelper.renderTemplate(this.templates[e], t), o = document.createElement("div"); return o.slot = r, o.dataset.generated = "template", o.appendChild(n), this.appendChild(o), this.fireCustomEvent("templateRendered", { templateType: e, context: t, element: o }), T`
      <slot name=${r}></slot>
    `}
      } let Y = _decorate([q("mgt-person")], function (t, r) {
        class MgtPerson extends r { constructor(...e) { super(...e), t(this) } } return {
          F: MgtPerson, d: [{ kind: "field", decorators: [property({ attribute: "person-query" })], key: "personQuery", value: void 0 }, { kind: "field", decorators: [property({ attribute: "user-id" })], key: "userId", value: void 0 }, { kind: "field", decorators: [property({ attribute: "show-name", type: Boolean })], key: "showName", value: void 0 }, { kind: "field", decorators: [property({ attribute: "show-email", type: Boolean })], key: "showEmail", value: void 0 }, { kind: "field", decorators: [property({ attribute: "person-details", type: Object })], key: "personDetails", value: void 0 }, { kind: "method", key: "attributeChangedCallback", value: function attributeChangedCallback(e, t, r) { _get(_getPrototypeOf(MgtPerson.prototype), "attributeChangedCallback", this).call(this, e, t, r), "person-query" != e && "user-id" != e || t === r || (this.personDetails = null, this.loadData()) } }, { kind: "get", static: !0, key: "styles", value: function styles() { return X } }, { kind: "method", key: "firstUpdated", value: function firstUpdated() { Providers.onProviderUpdated(() => this.loadData()), this.loadData() } }, { kind: "method", key: "loadData", value: async function loadData() { let t = Providers.globalProvider; if (t && t.state === e.ProviderState.SignedIn) if (this.userId) { let e = {}; await Promise.all([t.graph.getUser(this.userId).then(t => { t && (e.displayName = t.displayName, e.email = t.mail, this.requestUpdate()) }), t.graph.getUserPhoto(this.userId).then(t => { t && (e.image = t, this.requestUpdate()) })]), this.personDetails = e } else if (!this.personQuery && this.personDetails) this.personDetails.image || await this.loadImage(this.personDetails); else if (!this.personDetails && this.personQuery) if ("me" == this.personQuery) { let e = {}; await Promise.all([t.graph.getMe().then(t => { t && (e.displayName = t.displayName, e.email = t.mail || t.userPrincipalName) }), t.graph.myPhoto().then(t => { t && (e.image = t) })]), this.personDetails = e } else t.graph.findPerson(this.personQuery).then(e => { if (e && e.length > 0) { let t = e[0]; this.personDetails = t, t.scoredEmailAddresses && t.scoredEmailAddresses.length ? this.personDetails.email = t.scoredEmailAddresses[0].address : t.emailAddresses && t.emailAddresses.length && (this.personDetails.email = t.emailAddresses[0].address), this.loadImage(t) } }); else this.personDetails = null } }, { kind: "method", key: "loadImage", value: async function loadImage(e) { let t = Providers.globalProvider; if (e.userPrincipalName) { let r = e.userPrincipalName; t.graph.getUserPhoto(r).then(e => { this.personDetails.image = e, this.requestUpdate() }) } else this.personDetails.email && t.graph.findUserByEmail(this.personDetails.email).then(e => { if (e && e.length) { const r = e[0].id; e[0].personType && "OrganizationUser" == e[0].personType.subclass ? t.graph.getUserPhoto(e[0].scoredEmailAddresses[0].address).then(e => { this.personDetails.image = e, this.requestUpdate() }) : t.graph.getContactPhoto(r).then(e => { this.personDetails.image = e, this.requestUpdate() }) } }) } }, {
            kind: "method", key: "render", value: function render() {
              return this.renderTemplate("default", { person: this.personDetails }) || T`
        <div class="root">
          ${this.renderImage()} ${this.renderDetails()}
        </div>
      `}
          }, {
            kind: "method", key: "renderDetails", value: function renderDetails() {
              return this.showEmail || this.showName ? T`
        <span class="Details ${this.getImageSizeClass()}">
          ${this.renderNameAndEmail()}
        </span>
      `: null
            }
          }, {
            kind: "method", key: "renderImage", value: function renderImage() {
              return this.personDetails ? this.personDetails.image ? T`
          <img
            class="user-avatar ${this.getImageRowSpanClass()} ${this.getImageSizeClass()}"
            title=${this.personDetails.displayName}
            src=${this.personDetails.image}
          />
        `: T`
          <div
            class="user-avatar initials ${this.getImageRowSpanClass()} ${this.getImageSizeClass()}"
            title=${this.personDetails.displayName}
          >
            <span class="initials-text">
              ${this.getInitials()}
            </span>
          </div>
        `: this.renderEmptyImage()
            }
          }, {
            kind: "method", key: "renderEmptyImage", value: function renderEmptyImage() {
              return T`
      <i class="ms-Icon ms-Icon--Contact avatar-icon ${this.getImageRowSpanClass()} ${this.getImageSizeClass()}"></i>
    `}
          }, {
            kind: "method", key: "renderNameAndEmail", value: function renderNameAndEmail() {
              if (!this.personDetails || !this.showEmail && !this.showName) return; const e = this.showName ? T`
          <div class="user-name">${this.personDetails.displayName}</div>
        `: null, t = this.showEmail ? T`
          <div class="user-email">${this.personDetails.email}</div>
        `: null; return T`
      ${e} ${t}
    `}
          }, { kind: "method", key: "getInitials", value: function getInitials() { if (!this.personDetails) return ""; let e = ""; if (this.personDetails.givenName && (e += this.personDetails.givenName[0].toUpperCase()), this.personDetails.surname && (e += this.personDetails.surname[0].toUpperCase()), !e && this.personDetails.displayName) { const t = this.personDetails.displayName.split(" "); for (let r = 0; r < 2 && r < t.length; r++)t[r][0].match(/[a-z]/i) && (e += t[r][0].toUpperCase()) } return e } }, { kind: "method", key: "getImageRowSpanClass", value: function getImageRowSpanClass() { return this.showEmail && this.showName ? "row-span-2" : "" } }, { kind: "method", key: "getImageSizeClass", value: function getImageSizeClass() { return this.showEmail && this.showName ? "" : "small" } }]
        }
      }, MgtTemplatedComponent), ee = _decorate([q("mgt-login")], function (t, r) {
        return {
          F: class MgtLogin extends r { constructor() { super(), t(this), Providers.onProviderUpdated(() => this.loadState()), this.loadState() } }, d: [{ kind: "field", key: "_loginButtonRect", value: void 0 }, { kind: "field", key: "_popupRect", value: void 0 }, { kind: "field", key: "_openLeft", value: () => !1 }, { kind: "field", decorators: [property({ attribute: !1 })], key: "_showMenu", value: () => !1 }, { kind: "field", decorators: [property({ attribute: !1 })], key: "_loading", value: () => !0 }, { kind: "field", decorators: [property({ attribute: !1 })], key: "_user", value: void 0 }, { kind: "field", decorators: [property({ attribute: "user-details", type: Object })], key: "userDetails", value: void 0 }, { kind: "get", static: !0, key: "styles", value: function styles$1() { return K } }, { kind: "method", key: "updated", value: function updated(e) { if (!1 === e.get("_showMenu")) { const e = this.renderRoot.querySelector(".popup"); if (e && e.animate) { this._popupRect = e.getBoundingClientRect(); const t = this._loginButtonRect.left - this._popupRect.left, r = this._loginButtonRect.top - this._popupRect.top, n = this._loginButtonRect.width / this._popupRect.width, o = this._loginButtonRect.height / this._popupRect.height; e.animate([{ transformOrigin: "top left", transform: `\n              translate(${t}px, ${r}px)\n              scale(${n}, ${o})\n            `, backgroundColor: "#eaeaea" }, { transformOrigin: "top left", transform: "none", backgroundColor: "white" }], { duration: 100, easing: "ease-in-out", fill: "both" }) } } } }, { kind: "method", key: "firstUpdated", value: function firstUpdated() { window.addEventListener("click", e => { if (e.target !== this) { const e = this.renderRoot.querySelector(".popup"); e && (this._popupRect = e.getBoundingClientRect(), this._showMenu = !1) } }) } }, { kind: "method", key: "loadState", value: async function loadState() { if (this.userDetails) return void (this._user = null); const t = Providers.globalProvider; if (t) if (this._loading = !0, t.state === e.ProviderState.SignedIn) this._user = await t.graph.getMe(); else { if (t.state !== e.ProviderState.SignedOut) return; this._user = null } this._loading = !1 } }, { kind: "method", key: "onClick", value: function onClick(e) { if (e.stopPropagation(), this._user || this.userDetails) { const e = this.renderRoot.querySelector(".login-button"); if (e) { this._loginButtonRect = e.getBoundingClientRect(); let t = this._loginButtonRect.left, r = (window.innerWidth || document.documentElement.clientWidth) - this._loginButtonRect.right; this._openLeft = r < t, this._showMenu = !this._showMenu } } else this.fireCustomEvent("loginInitiated") && this.login() } }, { kind: "method", key: "login", value: async function login() { if (this.userDetails) return; const t = Providers.globalProvider; t && t.login && (await t.login(), t.state === e.ProviderState.SignedIn ? this.fireCustomEvent("loginCompleted") : this.fireCustomEvent("loginFailed"), await this.loadState()) } }, { kind: "method", key: "logout", value: async function logout() { if (!this.fireCustomEvent("logoutInitiated")) return; if (this.userDetails) return void (this.userDetails = null); const e = Providers.globalProvider; e && e.logout && (await e.logout(), this.fireCustomEvent("logoutCompleted")), this._showMenu = !1 } }, {
            kind: "method", key: "render", value: function render() {
              const e = this._user || this.userDetails ? this.renderLoggedIn() : this.renderLogIn(); return T`
      <div class="root">
        <button ?disabled="${this._loading}" class="login-button" @click=${this.onClick}>
          ${e}
        </button>
        ${this.renderMenu()}
      </div>
    `}
          }, {
            kind: "method", key: "renderLogIn", value: function renderLogIn() {
              return T`
      <i class="login-icon ms-Icon ms-Icon--Contact"></i>
      <span>
        Sign In
      </span>
    `}
          }, {
            kind: "method", key: "renderLoggedIn", value: function renderLoggedIn() {
              return this._user ? T`
        <mgt-person person-query="me" show-name />
      `: this.userDetails ? T`
        <mgt-person person-details=${JSON.stringify(this.userDetails)} show-name />
      `: this.renderLogIn()
            }
          }, {
            kind: "method", key: "renderMenu", value: function renderMenu() {
              if (!this._user && !this.userDetails) return; let e = this._user ? T`
          <mgt-person person-query="me" show-name show-email />
        `: T`
          <mgt-person person-details=${JSON.stringify(this.userDetails)} show-name show-email />
        `; return T`
      <div class="popup ${this._openLeft ? "open-left" : ""} ${this._showMenu ? "show-menu" : ""}">
        <div class="popup-content">
          <div>
            ${e}
          </div>
          <div class="popup-commands">
            <ul>
              <li>
                <button class="popup-command" @click=${this.logout}>
                  Sign Out
                </button>
              </li>
            </ul>
          </div>
        </div>
      </div>
    `}
          }]
        }
      }, MgtBaseComponent); const te = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

:host .header,
mgt-agenda .header {
  margin: var(--agenda-header-margin, 40px 10px 14px 10px);
  font-family: var(--default-font-family);
  font-size: var(--agenda-header-font-size, 24px);
  color: var(--agenda-header-color, #333333); }

:host .agenda > .group:first-child > .header,
mgt-agenda .agenda > .group:first-child > .header {
  margin-top: 0; }

:host .agenda-list,
mgt-agenda .agenda-list {
  list-style-type: none;
  padding: 0;
  margin: 0;
  font-family: var(--default-font-family);
  font-style: normal;
  font-weight: normal; }

:host .event,
mgt-agenda .event {
  background: var(--event-background, #ffffff);
  border: var(--event-border, solid 2px rgba(0, 0, 0, 0));
  box-shadow: var(--event-box-shadow, 0px 2px 8px rgba(0, 0, 0, 0.092));
  margin: var(--event-margin, 0px 10px 14px 10px);
  padding: var(--event-padding, 0px);
  display: flex; }

:host .narrow .event,
mgt-agenda .narrow .event {
  flex-direction: column; }

:host .event-time-container,
mgt-agenda .event-time-container {
  display: flex;
  flex-direction: column;
  margin: 18px 38px 18px 18px;
  width: 120px; }

:host .narrow .event-time-container,
mgt-agenda .narrow .event-time-container {
  margin: 14px 18px 8px 18px; }

:host .event-time,
mgt-agenda .event-time {
  font-size: var(--event-time-font-size, 12px);
  color: var(--event-time-color, #000000);
  font-weight: 600; }

:host .event-duration,
mgt-agenda .event-duration {
  color: rgba(16, 16, 16, 0.3); }

:host .event-details-container,
mgt-agenda .event-details-container {
  margin: 14px 18px 14px 0px; }

:host .narrow .event-details-container,
mgt-agenda .narrow .event-details-container {
  margin: 0px 18px 14px 18px; }

:host .event-subject,
mgt-agenda .event-subject {
  margin: 0px 18px 0px 0px;
  font-size: var(--event-subject-font-size, 19px);
  color: var(--event-subject-color, #333333); }

:host .event-location-container,
mgt-agenda .event-location-container {
  display: flex;
  margin: 8px 18px 0px 0px; }

:host .event-location,
mgt-agenda .event-location {
  font-size: var(--event-location-font-size, 12px);
  color: var(--event-location-color, #000000);
  margin: 0px 0px 0px 4px; }

:host .event-attendees,
mgt-agenda .event-attendees {
  --list-margin: 8px 0 0 0;
  --avatar-size-s: 20px; }

:host .event-other-container,
mgt-agenda .event-other-container {
  margin: 2px 16px 4px 16px;
  margin-left: auto; }

:host .loading-element,
mgt-agenda .loading-element {
  background: #f2f2f2;
  border-radius: 1px; }

:host .event-time-loading,
mgt-agenda .event-time-loading {
  width: 100px;
  height: 10px; }

:host .event-subject-loading,
mgt-agenda .event-subject-loading {
  width: 263px;
  height: 16px; }

:host .event-location-icon-loading,
mgt-agenda .event-location-icon-loading {
  width: 14px;
  height: 14px; }

:host .event-location-loading,
mgt-agenda .event-location-loading {
  width: 90px;
  height: 10px;
  margin: 2px 0px 0px 4px; }

:host .event-attendee-loading,
mgt-agenda .event-attendee-loading {
  width: 20px;
  height: 20px;
  border-radius: 10px;
  margin: 0 2px 0 0; }

`], re = "v1.0", ne = "https://graph.microsoft.com/", oe = "1.7.0"; var ie = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class CustomAuthenticationProvider { constructor(e) { this.provider = e } getAccessToken() { return ie(this, void 0, void 0, function* () { return new Promise((e, t) => { this.provider((r, n) => { n ? e(n) : t(r) }) }) }) } } class GraphError { constructor(e = -1) { this.statusCode = e, this.code = null, this.message = null, this.requestId = null, this.date = new Date, this.body = null } } var se = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class GraphErrorHandler { static constructError(e, t) { const r = new GraphError(t); return void 0 !== e.name && (r.code = e.name), r.body = e.toString(), r.message = e.message, r.date = new Date, r } static constructErrorFromResponse(e, t) { e = e.error; const r = new GraphError(t); r.code = e.code, r.message = e.message, void 0 !== e.innerError && (r.requestId = e.innerError["request-id"], r.date = new Date(e.innerError.date)); try { r.body = JSON.stringify(e) } catch (e) { } return r } static getError(e = null, t = -1, r) { return se(this, void 0, void 0, function* () { let n; if (n = e && e.error ? GraphErrorHandler.constructErrorFromResponse(e, t) : e && "Error" === e.constructor.name ? GraphErrorHandler.constructError(e, t) : new GraphError(t), "function" != typeof r) return n; r(n, null) }) } } const ae = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"], ce = e => { const t = e => e.replace(/\/+$/, ""), r = e => e.replace(/^\/+/, ""); return Array.prototype.slice.call(e).reduce((e, n) => [t(e), r(n)].join("/")) }, le = e => { const t = e.constructor.name; if ("Buffer" === t || "Blob" === t || "File" === t || "FormData" === t || "string" == typeof e) return e; if ("ArrayBuffer" === t) e = Buffer.from(e); else if ("Int8Array" === t || "Int16Array" === t || "Int32Array" === t || "Uint8Array" === t || "Uint16Array" === t || "Uint32Array" === t || "Uint8ClampedArray" === t || "Float32Array" === t || "Float64Array" === t || "DataView" === t) e = Buffer.from(e.buffer); else try { e = JSON.stringify(e) } catch (e) { throw new Error("Unable to stringify the content") } return e }; var de; !function (e) { e.ARRAYBUFFER = "arraybuffer", e.BLOB = "blob", e.DOCUMENT = "document", e.JSON = "json", e.RAW = "raw", e.STREAM = "stream", e.TEXT = "text" }(de || (de = {})); var ue, he, pe, ge, fe = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; !function (e) { e.TEXT_HTML = "text/html", e.TEXT_XML = "text/xml", e.APPLICATION_XML = "application/xml", e.APPLICATION_XHTML = "application/xhtml+xml" }(ue || (ue = {})), function (e) { e.TEXT_PLAIN = "text/plain", e.APPLICATION_JSON = "application/json" }(he || (he = {})), function (e) { e.DOCUMENT = "^(text\\/(html|xml))|(application\\/(xml|xhtml\\+xml))$", e.IMAGE = "^image\\/.+" }(pe || (pe = {})); class GraphResponseHandler { static parseDocumentResponse(e, t) { try { return "undefined" != typeof DOMParser ? new Promise((r, n) => { e.text().then(e => { try { const o = (new DOMParser).parseFromString(e, t); r(o) } catch (e) { n(e) } }) }) : Promise.resolve(e.body) } catch (e) { throw e } } static convertResponse(e, t) { return fe(this, void 0, void 0, function* () { const r = e.clone(); if (204 === r.status) return Promise.resolve(); let n; try { switch (t) { case de.ARRAYBUFFER: n = yield r.arrayBuffer(); break; case de.BLOB: n = yield r.blob(); break; case de.DOCUMENT: n = yield GraphResponseHandler.parseDocumentResponse(r, ue.TEXT_XML); break; case de.JSON: n = yield r.json(); break; case de.STREAM: n = yield Promise.resolve(r.body); break; case de.TEXT: n = yield r.text(); break; default: const e = r.headers.get("Content-type"); if (null !== e) { const t = e.split(";")[0]; n = new RegExp(pe.DOCUMENT).test(t) ? yield GraphResponseHandler.parseDocumentResponse(r, t) : new RegExp(pe.IMAGE).test(t) ? r.blob() : t === he.TEXT_PLAIN ? yield r.text() : t === he.APPLICATION_JSON ? yield r.json() : Promise.resolve(r.body) } else n = Promise.resolve(r.body) } } catch (e) { throw e } return n }) } static getResponse(e, t, r) { return fe(this, void 0, void 0, function* () { try { if (t === de.RAW) return Promise.resolve(e); { const n = yield GraphResponseHandler.convertResponse(e, t); if (!e.ok) throw n; if ("function" != typeof r) return n; r(null, n, e) } } catch (e) { throw e } }) } } class MiddlewareControl { constructor(e = []) { this.middlewareOptions = new Map; for (const t of e) { const e = t.constructor.name; this.middlewareOptions.set(e, t) } } getMiddlewareOptions(e) { return this.middlewareOptions.get(e) } setMiddlewareOptions(e, t) { this.middlewareOptions.set(e, t) } } !function (e) { e.GET = "GET", e.PATCH = "PATCH", e.POST = "POST", e.PUT = "PUT", e.DELETE = "DELETE" }(ge || (ge = {})); var me = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class GraphRequest { constructor(e, t, r) { this.parsePath = (e => { if (-1 !== e.indexOf("https://")) { const t = (e = e.replace("https://", "")).indexOf("/"); -1 !== t && (this.urlComponents.host = "https://" + e.substring(0, t), e = e.substring(t + 1, e.length)); const r = e.indexOf("/"); -1 !== r && (this.urlComponents.version = e.substring(0, r), e = e.substring(r + 1, e.length)) } "/" === e.charAt(0) && (e = e.substr(1)); const t = e.indexOf("?"); if (-1 === t) this.urlComponents.path = e; else { this.urlComponents.path = e.substr(0, t); const r = e.substring(t + 1, e.length).split("&"); for (const e of r) { const t = e.split("="), r = t[0], n = t[1]; -1 !== ae.indexOf(r) ? this.urlComponents.oDataQueryParams[r] = n : this.urlComponents.otherURLQueryParams[r] = n } } }), this.httpClient = e, this.config = t, this.urlComponents = { host: this.config.baseUrl, version: this.config.defaultVersion, oDataQueryParams: {}, otherURLQueryParams: {} }, this._headers = {}, this._options = {}, this._middlewareOptions = [], this.parsePath(r) } addCsvQueryParameter(e, t, r) { this.urlComponents.oDataQueryParams[e] = this.urlComponents.oDataQueryParams[e] ? this.urlComponents.oDataQueryParams[e] + "," : ""; let n = []; r.length > 1 && "string" == typeof t ? n = Array.prototype.slice.call(r) : "string" == typeof t ? n.push(t) : n = n.concat(t), this.urlComponents.oDataQueryParams[e] += n.join(",") } buildFullUrl() { const e = ce([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString(); return this.config.debugLogging && console.log(e), e } createQueryString() { const e = this.urlComponents, t = []; if (0 !== Object.keys(e.oDataQueryParams).length) for (const r in e.oDataQueryParams) e.oDataQueryParams.hasOwnProperty(r) && t.push(r + "=" + e.oDataQueryParams[r]); if (0 !== Object.keys(e.otherURLQueryParams).length) for (const r in e.otherURLQueryParams) e.otherURLQueryParams.hasOwnProperty(r) && t.push(r + "=" + e.otherURLQueryParams[r]); return t.length > 0 ? "?" + t.join("&") : "" } updateRequestOptions(e) { const t = Object.assign({}, e.headers); if (void 0 !== this.config.fetchOptions) { const t = Object.assign({}, this.config.fetchOptions); Object.assign(e, t), void 0 !== typeof this.config.fetchOptions.headers && (e.headers = Object.assign({}, this.config.fetchOptions.headers)) } Object.assign(e, this._options), void 0 !== e.headers && Object.assign(t, e.headers), Object.assign(t, this._headers), e.headers = t } send(e, t, r) { return me(this, void 0, void 0, function* () { let n; const o = new MiddlewareControl(this._middlewareOptions); this.updateRequestOptions(t); try { return n = (yield this.httpClient.sendRequest({ request: e, options: t, middlewareControl: o })).response, yield GraphResponseHandler.getResponse(n, this._responseType, r) } catch (e) { let t; throw void 0 !== n && (t = n.status), yield GraphErrorHandler.getError(e, t, r) } }) } header(e, t) { return this._headers[e] = t, this } headers(e) { for (const t in e) e.hasOwnProperty(t) && (this._headers[t] = e[t]); return this } option(e, t) { return this._options[e] = t, this } options(e) { for (const t in e) e.hasOwnProperty(t) && (this._options[t] = e[t]); return this } middlewareOptions(e) { return this._middlewareOptions = e, this } version(e) { return this.urlComponents.version = e, this } responseType(e) { return this._responseType = e, this } select(e) { return this.addCsvQueryParameter("$select", e, arguments), this } expand(e) { return this.addCsvQueryParameter("$expand", e, arguments), this } orderby(e) { return this.addCsvQueryParameter("$orderby", e, arguments), this } filter(e) { return this.urlComponents.oDataQueryParams.$filter = e, this } search(e) { return this.urlComponents.oDataQueryParams.$search = e, this } top(e) { return this.urlComponents.oDataQueryParams.$top = e, this } skip(e) { return this.urlComponents.oDataQueryParams.$skip = e, this } skipToken(e) { return this.urlComponents.oDataQueryParams.$skipToken = e, this } count(e) { return this.urlComponents.oDataQueryParams.$count = e.toString(), this } query(e) { const t = this.urlComponents.otherURLQueryParams; if ("string" == typeof e) { const r = e.split("="), n = r[0], o = r[1]; t[n] = o } else for (const r in e) e.hasOwnProperty(r) && (t[r] = e[r]); return this } get(e) { return me(this, void 0, void 0, function* () { const t = this.buildFullUrl(), r = { method: ge.GET }; try { return yield this.send(t, r, e) } catch (e) { throw e } }) } post(e, t) { return me(this, void 0, void 0, function* () { const r = this.buildFullUrl(), n = { method: ge.POST, body: le(e), headers: void 0 !== e.constructor && "FormData" === e.constructor.name ? {} : { "Content-Type": "application/json" } }; try { return yield this.send(r, n, t) } catch (e) { throw e } }) } create(e, t) { return me(this, void 0, void 0, function* () { try { return yield this.post(e, t) } catch (e) { throw e } }) } put(e, t) { return me(this, void 0, void 0, function* () { const r = this.buildFullUrl(), n = { method: ge.PUT, body: le(e), headers: { "Content-Type": "application/octet-stream" } }; try { return yield this.send(r, n, t) } catch (e) { throw e } }) } patch(e, t) { return me(this, void 0, void 0, function* () { const r = this.buildFullUrl(), n = { method: ge.PATCH, body: le(e), headers: { "Content-Type": "application/json" } }; try { return yield this.send(r, n, t) } catch (e) { throw e } }) } update(e, t) { return me(this, void 0, void 0, function* () { try { return yield this.patch(e, t) } catch (e) { throw e } }) } delete(e) { return me(this, void 0, void 0, function* () { const t = this.buildFullUrl(), r = { method: ge.DELETE }; try { return yield this.send(t, r, e) } catch (e) { throw e } }) } del(e) { return me(this, void 0, void 0, function* () { try { return yield this.delete(e) } catch (e) { throw e } }) } getStream(e) { return me(this, void 0, void 0, function* () { const t = this.buildFullUrl(), r = { method: ge.GET }; this.responseType(de.STREAM); try { return yield this.send(t, r, e) } catch (e) { throw e } }) } putStream(e, t) { return me(this, void 0, void 0, function* () { const r = this.buildFullUrl(), n = { method: ge.PUT, headers: { "Content-Type": "application/octet-stream" }, body: e }; try { return yield this.send(r, n, t) } catch (e) { throw e } }) } } var ye = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class HTTPClient { constructor(e) { this.middleware = e } sendRequest(e) { return ye(this, void 0, void 0, function* () { try { if (!(e.request instanceof Request) && void 0 === e.options) { const e = new Error; throw e.name = "InvalidRequestOptions", e.message = "Unable to execute the middleware, Please provide valid options for a request", e } return yield this.middleware.execute(e), e } catch (e) { throw e } }) } } var ke = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; const ve = () => { let e = ""; for (let t = 0; t < 32; t++)8 !== t && 12 !== t && 16 !== t && 20 !== t || (e += "-"), e += Math.floor(16 * Math.random()).toString(16); return e }, we = (e, t, r) => { let n = null; if (e instanceof Request) n = e.headers.get(r); else if (void 0 !== t && void 0 !== t.headers) if (t.headers instanceof Headers) n = t.headers.get(r); else if (t.headers instanceof Array) { const e = t.headers; for (let t = 0, o = e.length; t < o; t++)if (e[t][0] === r) { n = e[t][1]; break } } else void 0 !== t.headers[r] && (n = t.headers[r]); return n }, Te = (e, t, r, n) => { e instanceof Request ? e.headers.set(r, n) : void 0 !== t && (void 0 === t.headers ? t.headers = { [r]: n } : t.headers instanceof Headers ? t.headers.set(r, n) : t.headers instanceof Array ? t.headers.push([r, n]) : Object.assign(t.headers, { [r]: n })) }, Se = (e, t) => ke(void 0, void 0, void 0, function* () { const r = t.headers.get("Content-Type") ? yield t.blob() : yield Promise.resolve(void 0), { method: n, headers: o, referrer: i, referrerPolicy: s, mode: a, credentials: c, cache: l, redirect: d, integrity: u, keepalive: h, signal: p } = t; return new Request(e, { method: n, headers: o, body: r, referrer: i, referrerPolicy: s, mode: a, credentials: c, cache: l, redirect: d, integrity: u, keepalive: h, signal: p }) }); class AuthenticationHandlerOptions { constructor(e, t) { this.authenticationProvider = e, this.authenticationProviderOptions = t } } var be; !function (e) { e[e.NONE = 0] = "NONE", e[e.REDIRECT_HANDLER_ENABLED = 1] = "REDIRECT_HANDLER_ENABLED", e[e.RETRY_HANDLER_ENABLED = 2] = "RETRY_HANDLER_ENABLED", e[e.AUTHENTICATION_HANDLER_ENABLED = 4] = "AUTHENTICATION_HANDLER_ENABLED" }(be || (be = {})); class TelemetryHandlerOptions { constructor() { this.featureUsage = be.NONE } static updateFeatureUsageFlag(e, t) { let r; e.middlewareControl instanceof MiddlewareControl ? r = e.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions.name) : e.middlewareControl = new MiddlewareControl, void 0 === r && (r = new TelemetryHandlerOptions, e.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions.name, r)), r.setFeatureUsage(t) } setFeatureUsage(e) { this.featureUsage = this.featureUsage | e } getFeatureUsage() { return this.featureUsage.toString(16) } } var _e = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class AuthenticationHandler { constructor(e) { this.authenticationProvider = e } execute(e) { return _e(this, void 0, void 0, function* () { try { let t, r, n; e.middlewareControl instanceof MiddlewareControl && (t = e.middlewareControl.getMiddlewareOptions(AuthenticationHandlerOptions.name)), void 0 !== t && (r = t.authenticationProvider, n = t.authenticationProviderOptions), void 0 === r && (r = this.authenticationProvider); const o = `Bearer ${yield r.getAccessToken(n)}`; return Te(e.request, e.options, AuthenticationHandler.AUTHORIZATION_HEADER, o), TelemetryHandlerOptions.updateFeatureUsageFlag(e, be.AUTHENTICATION_HANDLER_ENABLED), yield this.nextMiddleware.execute(e) } catch (e) { throw e } }) } setNext(e) { this.nextMiddleware = e } } AuthenticationHandler.AUTHORIZATION_HEADER = "Authorization"; var Ae = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class HTTPMessageHandler { execute(e) { return Ae(this, void 0, void 0, function* () { try { return void (e.response = yield fetch(e.request, e.options)) } catch (e) { throw e } }) } } class RedirectHandlerOptions { constructor(e = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, t = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY) { if (e > RedirectHandlerOptions.MAX_MAX_REDIRECTS) { const e = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`); throw e.name = "MaxLimitExceeded", e } this.maxRedirects = e, this.shouldRedirect = t } } RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5, RedirectHandlerOptions.MAX_MAX_REDIRECTS = 20, RedirectHandlerOptions.DEFAULT_SHOULD_RETRY = (() => !0); class RetryHandlerOptions { constructor(e = RetryHandlerOptions.DEFAULT_DELAY, t = RetryHandlerOptions.DEFAULT_MAX_RETRIES, r = RetryHandlerOptions.DEFAULT_SHOULD_RETRY) { if (e > RetryHandlerOptions.MAX_DELAY && t > RetryHandlerOptions.MAX_MAX_RETRIES) { const e = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`); throw e.name = "MaxLimitExceeded", e } if (e > RetryHandlerOptions.MAX_DELAY) { const e = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`); throw e.name = "MaxLimitExceeded", e } if (t > RetryHandlerOptions.MAX_MAX_RETRIES) { const e = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`); throw e.name = "MaxLimitExceeded", e } this.delay = Math.min(e, RetryHandlerOptions.MAX_DELAY), this.maxRetries = Math.min(t, RetryHandlerOptions.MAX_MAX_RETRIES), this.shouldRetry = r } getMaxDelay() { return RetryHandlerOptions.MAX_DELAY } } RetryHandlerOptions.DEFAULT_DELAY = 3, RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3, RetryHandlerOptions.MAX_DELAY = 180, RetryHandlerOptions.MAX_MAX_RETRIES = 10, RetryHandlerOptions.DEFAULT_SHOULD_RETRY = (() => !0); var Ce = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class RedirectHandler { constructor(e = new RedirectHandlerOptions) { this.options = e } isRedirect(e) { return -1 !== RedirectHandler.REDIRECT_STATUS_CODES.indexOf(e.status) } hasLocationHeader(e) { return e.headers.has(RedirectHandler.LOCATION_HEADER) } getLocationHeader(e) { return e.headers.get(RedirectHandler.LOCATION_HEADER) } isRelativeURL(e) { return -1 === e.indexOf("://") } shouldDropAuthorizationHeader(e, t) { const r = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/, n = r.exec(e); let o, i; null !== n && (o = n[0]); const s = r.exec(t); return null !== s && (i = s[0]), void 0 !== o && void 0 !== i && o !== i } updateRequestUrl(e, t) { return Ce(this, void 0, void 0, function* () { t.request = t.request instanceof Request ? yield Se(e, t.request) : e }) } getOptions(e) { let t; return e.middlewareControl instanceof MiddlewareControl && (t = e.middlewareControl.getMiddlewareOptions(this.options.constructor.name)), void 0 === t && (t = Object.assign(new RedirectHandlerOptions, this.options)), t } executeWithRedirect(e, t, r) { return Ce(this, void 0, void 0, function* () { try { yield this.nextMiddleware.execute(e); const n = e.response; if (!(t < r.maxRedirects && this.isRedirect(n) && this.hasLocationHeader(n) && r.shouldRedirect(n))) return; if (++t, n.status === RedirectHandler.STATUS_CODE_SEE_OTHER) e.options.method = ge.GET, delete e.options.body; else { const t = this.getLocationHeader(n); !this.isRelativeURL(t) && this.shouldDropAuthorizationHeader(n.url, t) && Te(e.request, e.options, RedirectHandler.AUTHORIZATION_HEADER, void 0), yield this.updateRequestUrl(t, e) } yield this.executeWithRedirect(e, t, r) } catch (e) { throw e } }) } execute(e) { return Ce(this, void 0, void 0, function* () { try { const t = 0, r = this.getOptions(e); return e.options.redirect = RedirectHandler.MANUAL_REDIRECT, TelemetryHandlerOptions.updateFeatureUsageFlag(e, be.REDIRECT_HANDLER_ENABLED), yield this.executeWithRedirect(e, t, r) } catch (e) { throw e } }) } setNext(e) { this.nextMiddleware = e } } RedirectHandler.REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308], RedirectHandler.STATUS_CODE_SEE_OTHER = 303, RedirectHandler.LOCATION_HEADER = "Location", RedirectHandler.AUTHORIZATION_HEADER = "Authorization", RedirectHandler.MANUAL_REDIRECT = "manual"; var Ie = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class RetryHandler { constructor(e = new RetryHandlerOptions) { this.options = e } isRetry(e) { return -1 !== RetryHandler.RETRY_STATUS_CODES.indexOf(e.status) } isBuffered(e, t) { const r = e instanceof Request ? e.method : t.method; if (r === ge.PUT || r === ge.PATCH || r === ge.POST) { if ("application/octet-stream" === we(e, t, "Content-Type")) return !1 } return !0 } getDelay(e, t, r) { const n = () => Number(Math.random().toFixed(3)), o = void 0 !== e.headers ? e.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null; let i; return i = null !== o ? Number.isNaN(Number(o)) ? Math.round((new Date(o).getTime() - Date.now()) / 1e3) : Number(o) : t >= 2 ? this.getExponentialBackOffTime(t) + r + n() : r + n(), Math.min(i, this.options.getMaxDelay() + n()) } getExponentialBackOffTime(e) { return Math.round(.5 * (Math.pow(2, e) - 1)) } sleep(e) { return Ie(this, void 0, void 0, function* () { const t = 1e3 * e; return new Promise(e => setTimeout(e, t)) }) } getOptions(e) { let t; return e.middlewareControl instanceof MiddlewareControl && (t = e.middlewareControl.getMiddlewareOptions(this.options.constructor.name)), void 0 === t && (t = Object.assign(new RetryHandlerOptions, this.options)), t } executeWithRetry(e, t, r) { return Ie(this, void 0, void 0, function* () { try { if (yield this.nextMiddleware.execute(e), t < r.maxRetries && this.isRetry(e.response) && this.isBuffered(e.request, e.options) && r.shouldRetry(r.delay, t, e.request, e.options, e.response)) { ++t, Te(e.request, e.options, RetryHandler.RETRY_ATTEMPT_HEADER, t.toString()); const n = this.getDelay(e.response, t, r.delay); return yield this.sleep(n), yield this.executeWithRetry(e, t, r) } return } catch (e) { throw e } }) } execute(e) { return Ie(this, void 0, void 0, function* () { try { const t = 0, r = this.getOptions(e); return TelemetryHandlerOptions.updateFeatureUsageFlag(e, be.RETRY_HANDLER_ENABLED), yield this.executeWithRetry(e, t, r) } catch (e) { throw e } }) } setNext(e) { this.nextMiddleware = e } } RetryHandler.RETRY_STATUS_CODES = [429, 503, 504], RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt", RetryHandler.RETRY_AFTER_HEADER = "Retry-After"; var Ee = function (e, t, r, n) { return new (r || (r = Promise))(function (o, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n.throw(e)) } catch (e) { i(e) } } function step(e) { e.done ? o(e.value) : new r(function (t) { t(e.value) }).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) }) }; class TelemetryHandler { execute(e) { return Ee(this, void 0, void 0, function* () { try { let t = we(e.request, e.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER); null === t && (t = ve(), Te(e.request, e.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER, t)); let r, n = `${TelemetryHandler.PRODUCT_NAME}/${oe}`; if (e.middlewareControl instanceof MiddlewareControl && (r = e.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions.name)), void 0 !== r) { const e = r.getFeatureUsage(); n += ` (${TelemetryHandler.FEATURE_USAGE_STRING}=${e})` } return Te(e.request, e.options, TelemetryHandler.SDK_VERSION_HEADER, n), yield this.nextMiddleware.execute(e) } catch (e) { throw e } }) } setNext(e) { this.nextMiddleware = e } } TelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id", TelemetryHandler.SDK_VERSION_HEADER = "SdkVersion", TelemetryHandler.PRODUCT_NAME = "graph-js", TelemetryHandler.FEATURE_USAGE_STRING = "featureUsage"; const Pe = () => new Function("try {return this === global;}catch(e){return false;}")(); class HTTPClientFactory { static createWithAuthenticationProvider(e) { const t = new AuthenticationHandler(e), r = new RetryHandler(new RetryHandlerOptions), n = new TelemetryHandler, o = new HTTPMessageHandler; if (t.setNext(r), Pe()) { const e = new RedirectHandler(new RedirectHandlerOptions); r.setNext(e), e.setNext(n) } else r.setNext(n); return n.setNext(o), HTTPClientFactory.createWithMiddleware(t) } static createWithMiddleware(e) { return new HTTPClient(e) } } const xe = () => { if ("undefined" == typeof Promise && "undefined" == typeof fetch) { const e = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them."); throw e.name = "PolyFillNotAvailable", e } if ("undefined" == typeof Promise) { const e = new Error("Library cannot function without Promise. So, please provide polyfill for it."); throw e.name = "PolyFillNotAvailable", e } if ("undefined" == typeof fetch) { const e = new Error("Library cannot function without fetch. So, please provide polyfill for it."); throw e.name = "PolyFillNotAvailable", e } return !0 }; class Client { constructor(e) { this.config = { baseUrl: ne, debugLogging: !1, defaultVersion: re }; try { xe() } catch (e) { throw e } for (const t in e) e.hasOwnProperty(t) && (this.config[t] = e[t]); let t; if (void 0 !== e.authProvider && void 0 !== e.middleware) { const e = new Error; throw e.name = "AmbiguityInInitialization", e.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both", e } if (void 0 !== e.authProvider) t = HTTPClientFactory.createWithAuthenticationProvider(e.authProvider); else { if (void 0 === e.middleware) { const e = new Error; throw e.name = "InvalidMiddlewareChain", e.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain", e } t = new HTTPClient(e.middleware) } this.httpClient = t } static init(e) { const t = {}; for (const r in e) e.hasOwnProperty(r) && (t[r] = "authProvider" === r ? new CustomAuthenticationProvider(e[r]) : e[r]); return Client.initWithMiddleware(t) } static initWithMiddleware(e) { try { return new Client(e) } catch (e) { throw e } } api(e) { return new GraphRequest(this.httpClient, this.config, e) } } const De = "0.1.1"; function prepScopes(...e) { return [new AuthenticationHandlerOptions(void 0, { scopes: e })] } class SdkVersionMiddleware { constructor() { _defineProperty(this, "nextMiddleware", void 0) } async execute(e) { try { let t = `mgt/${De}`; return t += ", " + we(e.request, e.options, "SdkVersion"), Te(e.request, e.options, "SdkVersion", t), await this.nextMiddleware.execute(e) } catch (e) { throw e } } setNext(e) { this.nextMiddleware = e } } class Graph { constructor(e) { if (_defineProperty(this, "client", void 0), e) { let t = new AuthenticationHandler(e); const r = new RetryHandler(new RetryHandlerOptions), n = new TelemetryHandler, o = new SdkVersionMiddleware, i = new HTTPMessageHandler; t.setNext(r), r.setNext(n), n.setNext(o), o.setNext(i), this.client = Client.initWithMiddleware({ middleware: t }) } } blobToBase64(e) { return new Promise((t, r) => { const n = new FileReader; n.onerror = r, n.onload = (e => { t(n.result) }), n.readAsDataURL(e) }) } async getMe() { return this.client.api("me").middlewareOptions(prepScopes("user.read")).get() } async getUser(e) { return this.client.api(`/users/${e}`).middlewareOptions(prepScopes("user.readbasic.all")).get() } async findPerson(e) { let t = await this.client.api("/me/people").search('"' + e + '"').middlewareOptions(prepScopes("people.read")).get(); return t ? t.value : null } async findContactByEmail(e) { let t = await this.client.api("/me/contacts").filter(`emailAddresses/any(a:a/address eq '${e}')`).middlewareOptions(prepScopes("contacts.read")).get(); return t ? t.value : null } async findUserByEmail(e) { return Promise.all([this.findPerson(e), this.findContactByEmail(e)]).then(([e, t]) => (e || []).concat(t || [])) } async getPhotoForResource(e, t) { try { let r = await this.client.api(`${e}/photo/$value`).version("beta").responseType(de.BLOB).middlewareOptions(prepScopes(...t)).get(); return await this.blobToBase64(r) } catch (e) { return null } } async myPhoto() { return this.getPhotoForResource("me", ["user.read"]) } async getUserPhoto(e) { return this.getPhotoForResource(`users/${e}`, ["user.readbasic.all"]) } async getContactPhoto(e) { return this.getPhotoForResource(`me/contacts/${e}`, ["contacts.read"]) } async getEvents(e, t) { let r = `/me/calendarview?${`startdatetime=${e.toISOString()}`}&${`enddatetime=${t.toISOString()}`}`, n = await this.client.api(r).middlewareOptions(prepScopes("calendars.read")).orderby("start/dateTime").get(); return n ? n.value : null } async getPeople() { let e = await this.client.api("/me/people").middlewareOptions(prepScopes("people.read")).filter("personType/class eq 'Person'").get(); return e ? e.value : null } async planner_getAllMyPlans() { let e = await this.client.api("/me/planner/plans").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get(); return e && e.value } async planner_getSinglePlan(e) { return await this.client.api(`/planner/plans/${e}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get() } async planner_getBucketsForPlan(e) { let t = await this.client.api(`/planner/plans/${e}/buckets`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get(); return t && t.value } async planner_getTasksForBucket(e) { let t = await this.client.api(`/planner/buckets/${e}/tasks`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.Read.All")).get(); return t && t.value } async planner_setTaskDetails(e, t, r) { return await this.client.api(`/planner/tasks/${e}`).header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.ReadWrite.All")).header("If-Match", r).patch(JSON.stringify(t)) } async planner_setTaskComplete(e, t) { return this.planner_setTaskDetails(e, { percentComplete: 100 }, t) } async planner_setTaskIncomplete(e, t) { return this.planner_setTaskDetails(e, { percentComplete: 0 }, t) } async planner_addTask(e) { return this.client.api("/planner/tasks").header("Cache-Control", "no-store").middlewareOptions(prepScopes("Group.ReadWrite.All")).post(e) } async planner_removeTask(e, t) { return this.client.api(`/planner/tasks/${e}`).header("Cache-Control", "no-store").header("If-Match", t).middlewareOptions(prepScopes("Group.ReadWrite.All")).delete() } async todo_getAllMyGroups() { let e = await this.client.api("/me/outlook/taskGroups").header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.Read")).get(); return e && e.value } async todo_getSingleGroup(e) { return await this.client.api(`/me/outlook/taskGroups/${e}`).header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.Read")).get() } async todo_getFoldersForGroup(e) { let t = await this.client.api(`/me/outlook/taskGroups/${e}/taskFolders`).header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.Read")).get(); return t && t.value } async todo_getAllTasksForFolder(e) { let t = await this.client.api(`/me/outlook/taskFolders/${e}/tasks`).header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.Read")).get(); return t && t.value } async todo_setTaskDetails(e, t, r) { return await this.client.api(`/me/outlook/tasks/${e}`).header("Cache-Control", "no-store").version("beta").header("If-Match", r).middlewareOptions(prepScopes("Tasks.ReadWrite")).patch(t) } async todo_setTaskComplete(e, t) { return await this.todo_setTaskDetails(e, { status: "completed", isReminderOn: !1 }, t) } async todo_setTaskIncomplete(e, t) { return await this.todo_setTaskDetails(e, { status: "notStarted", isReminderOn: !0 }, t) } async todo_addTask(e) { let { parentFolderId: t = null } = e; return t ? await this.client.api(`/me/outlook/taskFolders/${t}/tasks`).header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.ReadWrite")).post(e) : await this.client.api("/me/outlook/tasks").header("Cache-Control", "no-store").version("beta").middlewareOptions(prepScopes("Tasks.ReadWrite")).post(e) } async todo_removeTask(e, t) { return await this.client.api(`/me/outlook/tasks/${e}`).header("Cache-Control", "no-store").version("beta").header("If-Match", t).middlewareOptions(prepScopes("Tasks.ReadWrite")).delete() } } let Re = _decorate([q("mgt-agenda")], function (t, r) {
        class MgtAgenda extends r { constructor() { super(), t(this), this.onResize = this.onResize.bind(this) } } return {
          F: MgtAgenda, d: [{ kind: "field", key: "_firstUpdated", value: () => !1 }, { kind: "field", decorators: [property({ attribute: !1 })], key: "_isNarrow", value: void 0 }, { kind: "field", decorators: [property({ attribute: !1 })], key: "_loading", value: () => !0 }, { kind: "field", decorators: [property({ attribute: "events" })], key: "events", value: void 0 }, { kind: "field", decorators: [property({ attribute: "group-by-day", type: Boolean, reflect: !0 })], key: "groupByDay", value: () => !1 }, { kind: "field", decorators: [property({ attribute: "date", type: String, reflect: !0 })], key: "date", value: void 0 }, { kind: "field", decorators: [property({ attribute: "days", type: Number, reflect: !0 })], key: "days", value: () => 3 }, { kind: "field", decorators: [property({ attribute: "event-query", type: String })], key: "eventQuery", value: void 0 }, { kind: "get", static: !0, key: "styles", value: function styles() { return te } }, { kind: "method", key: "firstUpdated", value: function firstUpdated() { this._firstUpdated = !0, Providers.onProviderUpdated(() => this.loadData()), this.loadData() } }, { kind: "method", key: "connectedCallback", value: function connectedCallback() { this._isNarrow = this.offsetWidth < 600, _get(_getPrototypeOf(MgtAgenda.prototype), "connectedCallback", this).call(this), window.addEventListener("resize", this.onResize) } }, { kind: "method", key: "disconnectedCallback", value: function disconnectedCallback() { window.removeEventListener("resize", this.onResize), _get(_getPrototypeOf(MgtAgenda.prototype), "disconnectedCallback", this).call(this) } }, { kind: "method", key: "attributeChangedCallback", value: function attributeChangedCallback(e, t, r) { "date" !== e && "days" !== e || (this.events = null, this.loadData()), _get(_getPrototypeOf(MgtAgenda.prototype), "attributeChangedCallback", this).call(this, e, t, r) } }, { kind: "method", key: "onResize", value: function onResize() { this._isNarrow = this.offsetWidth < 600 } }, { kind: "method", key: "loadData", value: async function loadData() { if (this.events) return; if (!this._firstUpdated) return; let t = Providers.globalProvider; if (t && t.state === e.ProviderState.SignedIn) { if (this._loading = !0, this.eventQuery) try { let e, r, n = this.eventQuery.split("|"); n.length > 1 ? (r = n[0].trim(), e = n[1].trim()) : r = this.eventQuery; let o = await t.graph.client.api(r); e && (o = o.middlewareOptions(prepScopes(e))); let i = await o.get(); i && i.value && (this.events = i.value) } catch (e) { } else { let e = this.date ? new Date(this.date) : new Date; e.setHours(0, 0, 0, 0); let r = new Date; r.setHours(0, 0, 0, 0), r.setDate(e.getDate() + this.days), this.events = await t.graph.getEvents(e, r) } this._loading = !1 } else t && t.state === e.ProviderState.Loading ? this._loading = !0 : this._loading = !1 } }, {
            kind: "method", key: "render", value: function render() {
              return this._isNarrow = this.offsetWidth < 600, T`
      <div class="agenda ${this._isNarrow ? "narrow" : ""}">
        ${this.renderAgenda()}
      </div>
    `}
          }, {
            kind: "method", key: "renderAgenda", value: function renderAgenda() {
              if (this._loading) return this.renderTemplate("loading", null) || this.renderLoading(); if (this.events) {
                let e = this.renderTemplate("default", { events: this.events }); if (e) return e; if (this.groupByDay) {
                  let e = {}; for (let t = 0; t < this.events.length; t++) { let r = this.getDateHeaderFromDateTimeString(this.events[t].start.dateTime); e[r] = e[r] || [], e[r].push(this.events[t]) } return T`
          <div class="agenda grouped ${this._isNarrow ? "narrow" : ""}">
            ${Object.keys(e).map(t => T`
                  <div class="group">
                    ${this.renderTemplate("header", { header: t }, "header-" + t) || T`
                        <div class="header">${t}</div>
                      `}
                    ${this.renderListOfEvents(e[t])}
                  </div>
                `)}
          </div>
        `} return this.renderListOfEvents(this.events)
              } return this.renderTemplate("no-data", null) || T``
            }
          }, {
            kind: "method", key: "renderListOfEvents", value: function renderListOfEvents(e) {
              return T`
      <ul class="agenda-list">
        ${e.map(e => T`
              <li>
                ${this.renderTemplate("event", { event: e }, e.id) || this.renderEvent(e)}
              </li>
            `)}
      </ul>
    `}
          }, {
            kind: "method", key: "renderLoading", value: function renderLoading() {
              return T`
      <div class="event">
        <div class="event-time-container">
          <div class="event-time-loading loading-element"></div>
        </div>
        <div class="event-details-container">
          <div class="event-subject-loading loading-element"></div>
          <div class="event-location-container">
            <div class="event-location-icon-loading loading-element"></div>
            <div class="event-location-loading loading-element"></div>
          </div>
          <div class="event-location-container">
            <div class="event-attendee-loading loading-element"></div>
            <div class="event-attendee-loading loading-element"></div>
            <div class="event-attendee-loading loading-element"></div>
          </div>
        </div>
      </div>
    `}
          }, {
            kind: "method", key: "renderEvent", value: function renderEvent(e) {
              return T`
      <div class="event">
        <div class="event-time-container">
          <div class="event-time">${this.getEventTimeString(e)}</div>
        </div>
        <div class="event-details-container">
          <div class="event-subject">${e.subject}</div>
          ${this.renderLocation(e)} ${this.renderAttendies(e)}
        </div>
        ${this.templates["event-other"] ? T`
              <div class="event-other-container">
                ${this.renderTemplate("event-other", { event: e }, e.id + "-other")}
              </div>
            `: ""}
      </div>
    `}
          }, {
            kind: "method", key: "renderLocation", value: function renderLocation(e) {
              return e.location.displayName ? T`
      <div class="event-location-container">
        <svg width="10" height="13" viewBox="0 0 10 13" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M4.99989 6.49989C4.15159 6.49989 3.46143 5.81458 3.46143 4.97224C3.46143 4.12965 4.15159 3.44434 4.99989 3.44434C5.84845 3.44434 6.53835 4.12965 6.53835 4.97224C6.53835 5.81458 5.84845 6.49989 4.99989 6.49989Z"
            stroke="black"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M8.1897 7.57436L5.00029 12L1.80577 7.56765C0.5971 6.01895 0.770299 3.47507 2.17681 2.12383C2.93098 1.39918 3.93367 1 5.00029 1C6.06692 1 7.06961 1.39918 7.82401 2.12383C9.23075 3.47507 9.40372 6.01895 8.1897 7.57436Z"
            stroke="black"
          />
        </svg>
        <div class="event-location">${e.location.displayName}</div>
      </div>
    `: null
            }
          }, {
            kind: "method", key: "renderAttendies", value: function renderAttendies(e) {
              return e.attendees.length ? T`
      <mgt-people
        class="event-attendees"
        people=${JSON.stringify(e.attendees.map(e => ({ displayName: e.emailAddress.name, email: e.emailAddress.address })))}
      ></mgt-people>
    `: null
            }
          }, { kind: "method", key: "getEventTimeString", value: function getEventTimeString(e) { if (e.isAllDay) return "ALL DAY"; return `${this.prettyPrintTimeFromDateTime(new Date(e.start.dateTime))} - ${this.prettyPrintTimeFromDateTime(new Date(e.end.dateTime))}` } }, { kind: "method", key: "prettyPrintTimeFromDateTime", value: function prettyPrintTimeFromDateTime(e) { e.setMinutes(e.getMinutes() - e.getTimezoneOffset()); let t = e.getHours(), r = e.getMinutes(), n = t >= 12 ? "PM" : "AM"; return `${t = (t %= 12) || 12}:${r < 10 ? "0" + r : r} ${n}` } }, { kind: "method", key: "getDateHeaderFromDateTimeString", value: function getDateHeaderFromDateTimeString(e) { let t = new Date(e); t.setMinutes(t.getMinutes() - t.getTimezoneOffset()); let r = t.getDay(), n = t.getMonth(), o = t.getDate(), i = t.getFullYear(); return `${["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][r]}, ${["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][n]} ${o}, ${i}` } }, { kind: "method", key: "getEventDuration", value: function getEventDuration(e) { let t = new Date(e.start.dateTime), r = new Date(e.end.dateTime), n = new Date, o = ""; n > t && (t = n); let i = r.getTime() - t.getTime(); var s = Math.round(i / 6e4); if (s > 1440 || e.isAllDay) o = Math.ceil(s / 1440) + "d"; else if (s > 60) { o = Math.round(s / 60) + "h"; let e = s % 60; e && (o += e + "m") } else o = s + "m"; return o } }]
        }
      }, MgtTemplatedComponent); const Oe = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

:host .people-list,
mgt-people .people-list {
  list-style-type: none;
  margin: var(--list-margin, 8px 4px 8px 8px);
  padding: 0;
  font-family: var(--default-font-family, "Segoe UI");
  font-style: normal;
  font-weight: normal;
  display: flex; }

:host .people-person,
mgt-people .people-person {
  margin: var(--avatar-margin, 0 4px 0 0);
  display: flex; }

`]; let Ue = _decorate([q("mgt-people")], function (t, r) {
        return {
          F: class MgtPeople extends r { constructor() { super(), t(this) } }, d: [{ kind: "field", key: "_firstUpdated", value: () => !1 }, { kind: "field", decorators: [property({ attribute: "people", type: Object })], key: "people", value: () => null }, { kind: "field", decorators: [property({ attribute: "show-max", type: Number })], key: "showMax", value: () => 3 }, { kind: "get", static: !0, key: "styles", value: function styles() { return Oe } }, { kind: "method", key: "firstUpdated", value: function firstUpdated() { this._firstUpdated = !0, Providers.onProviderUpdated(() => this.loadPeople()), this.loadPeople() } }, { kind: "method", key: "loadPeople", value: async function loadPeople() { if (this._firstUpdated && !this.people) { let t = Providers.globalProvider; if (t && t.state === e.ProviderState.SignedIn) { let e = Providers.globalProvider.graph; this.people = (await e.getPeople()).slice(0, this.showMax) } } } }, {
            kind: "method", key: "render", value: function render() {
              return this.people ? this.renderTemplate("default", { people: this.people }) || T`
          <ul class="people-list">
            ${this.people.slice(0, this.showMax).map(e => T`
                  <li class="people-person">
                    ${this.renderTemplate("person", { person: e }, e.displayName) || this.renderPerson(e)}
                  </li>
                `)}
            ${this.people.length > this.showMax ? this.renderTemplate("overflow", { people: this.people, max: this.showMax, extra: this.people.length - this.showMax }) || T`
                  <li>+${this.people.length - this.showMax}</li>
                `: null}
          </ul>
        `: this.renderTemplate("no-data", null) || T``
            }
          }, {
            kind: "method", key: "renderPerson", value: function renderPerson(e) {
              return T`
      <mgt-person person-details=${JSON.stringify(e)}></mgt-person>
    `}
          }]
        }
      }, MgtTemplatedComponent); const Ne = (e, t) => { const r = e.startNode.parentNode, n = void 0 === t ? e.endNode : t.startNode, o = r.insertBefore(p(), n); r.insertBefore(p(), n); const i = new NodePart(e.options); return i.insertAfterNode(o), i }, Me = (e, t) => (e.setValue(t), e.commit(), e), Le = (e, t, r) => { const n = e.startNode.parentNode, o = r ? r.startNode : e.endNode, i = t.endNode.nextSibling; i !== o && ((e, t, r = null, n = null) => { let o = t; for (; o !== r;) { const t = o.nextSibling; e.insertBefore(o, n), o = t } })(n, t.startNode, i, o) }, He = e => { i(e.startNode.parentNode, e.startNode, e.endNode.nextSibling) }, Fe = (e, t, r) => { const n = new Map; for (let o = t; o <= r; o++)n.set(e[o], o); return n }, qe = new WeakMap, je = new WeakMap, $e = r((e, t, r) => { let n; return void 0 === r ? r = t : void 0 !== t && (n = t), t => { if (!(t instanceof NodePart)) throw new Error("repeat can only be used in text bindings"); const o = qe.get(t) || [], i = je.get(t) || [], s = [], a = [], c = []; let l, d, u = 0; for (const t of e) c[u] = n ? n(t, u) : u, a[u] = r(t, u), u++; let h = 0, p = o.length - 1, g = 0, f = a.length - 1; for (; h <= p && g <= f;)if (null === o[h]) h++; else if (null === o[p]) p--; else if (i[h] === c[g]) s[g] = Me(o[h], a[g]), h++ , g++; else if (i[p] === c[f]) s[f] = Me(o[p], a[f]), p-- , f--; else if (i[h] === c[f]) s[f] = Me(o[h], a[f]), Le(t, o[h], s[f + 1]), h++ , f--; else if (i[p] === c[g]) s[g] = Me(o[p], a[g]), Le(t, o[p], o[h]), p-- , g++; else if (void 0 === l && (l = Fe(c, g, f), d = Fe(i, h, p)), l.has(i[h])) if (l.has(i[p])) { const e = d.get(c[g]), r = void 0 !== e ? o[e] : null; if (null === r) { const e = Ne(t, o[h]); Me(e, a[g]), s[g] = e } else s[g] = Me(r, a[g]), Le(t, r, o[h]), o[e] = null; g++ } else He(o[p]), p--; else He(o[h]), h++; for (; g <= f;) { const e = Ne(t, s[f + 1]); Me(e, a[g]), s[g++] = e } for (; h <= p;) { const e = o[h++]; null !== e && He(e) } qe.set(t, s), je.set(t, c) } }); window.navigator.userAgent.match("Trident") && (DOMTokenList.prototype.toggle = function (e, t) { return void 0 === t || t ? this.add(e) : this.remove(e), void 0 === t || t }); const Be = new WeakMap, Ve = new WeakMap, ze = r(e => t => { if (!(t instanceof AttributePart) || t instanceof PropertyPart || "class" !== t.committer.name || t.committer.parts.length > 1) throw new Error("The `classMap` directive must be used in the `class` attribute and must be the only part in the attribute."); Ve.has(t) || (t.committer.element.className = t.committer.strings.join(" "), Ve.set(t, !0)); const r = Be.get(t); for (const n in r) n in e || t.committer.element.classList.remove(n); for (const n in e) r && r[n] === e[n] || t.committer.element.classList.toggle(n, Boolean(e[n])); Be.set(t, e) }); class TaskSourceBase { constructor(e) { this.graph = e } async me() { return await this.graph.getMe() } } class PlannerTaskSource extends TaskSourceBase { async getMyDressers() { return (await this.graph.planner_getAllMyPlans()).map(e => ({ id: e.id, title: e.title })) } async getSingleDresser(e) { let t = await this.graph.planner_getSinglePlan(e); return { id: t.id, title: t.title, _raw: t } } async getDrawersForDresser(e) { return (await this.graph.planner_getBucketsForPlan(e)).map(e => ({ id: e.id, parentId: e.planId, name: e.name, _raw: e })) } async getAllTasksForDrawer(e) { return (await this.graph.planner_getTasksForBucket(e)).map(e => ({ id: e.id, immediateParentId: e.bucketId, topParentId: e.planId, name: e.title, eTag: e["@odata.etag"], completed: 100 === e.percentComplete, dueDate: e.dueDateTime, assignments: e.assignments, _raw: e })) } async setTaskComplete(e, t) { return await this.graph.planner_setTaskComplete(e, t) } async setTaskIncomplete(e, t) { return await this.graph.planner_setTaskIncomplete(e, t) } async addTask(e) { return await this.graph.planner_addTask({ title: e.name, bucketId: e.immediateParentId, planId: e.topParentId, dueDateTime: e.dueDate, assignments: e.assignments }) } async removeTask(e, t) { return await this.graph.planner_removeTask(e, t) } } class TodoTaskSource extends TaskSourceBase { async getMyDressers() { return (await this.graph.todo_getAllMyGroups()).map(e => ({ id: e.id, secondaryId: e.groupKey, title: e.name, _raw: e })) } async getSingleDresser(e) { let t = await this.graph.todo_getSingleGroup(e); return { id: t.id, secondaryId: t.groupKey, title: t.name, _raw: t } } async getDrawersForDresser(e) { return (await this.graph.todo_getFoldersForGroup(e)).map(t => ({ id: t.id, parentId: e, name: t.name, _raw: t })) } async getAllTasksForDrawer(e, t) { return (await this.graph.todo_getAllTasksForFolder(e)).map(r => ({ id: r.id, immediateParentId: e, topParentId: t, name: r.subject, eTag: r["@odata.etag"], completed: !!r.completedDateTime, dueDate: r.dueDateTime && r.dueDateTime.dateTime, assignments: {}, _raw: r })) } async setTaskComplete(e, t) { return await this.graph.todo_setTaskComplete(e, t) } async setTaskIncomplete(e, t) { return await this.graph.todo_setTaskIncomplete(e, t) } async addTask(e) { let t = { subject: e.name, assignedTo: (e.assignments, "John Doe"), parentFolderId: e.immediateParentId }; return e.dueDate && (t.dueDateTime = { dateTime: e.dueDate, timeZone: "UTC" }), await this.graph.todo_addTask(t) } async removeTask(e, t) { return await this.graph.todo_removeTask(e, t) } } const Ge = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
mgt-tasks,
:host {
  font-family: var(--default-font-family, "Segoe UI");
  display: flex;
  flex-direction: column; }

mgt-tasks .TaskIcon,
:host .TaskIcon {
  font-family: 'FabricMDL2Icons';
  text-align: center;
  justify-self: center;
  align-content: center;
  align-self: center;
  vertical-align: middle;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none; }

mgt-tasks .Header,
:host .Header {
  padding: var(--tasks-header-padding, 0px 10px 0 10px);
  margin: var(--tasks-header-margin, 0 0 10px 0); }

mgt-tasks .TaskIcon.Divider,
:host .TaskIcon.Divider {
  vertical-align: initial;
  margin: 0 12px;
  font-size: 16px; }

mgt-tasks .Header .PlannerTitle,
:host .Header .PlannerTitle {
  padding: var(--tasks-title-padding, 0px 0px 0px 0px);
  display: flex;
  align-items: center;
  align-content: center; }

mgt-tasks select,
:host select {
  font-family: var(--default-font-family, "Segoe UI");
  border: none;
  -moz-appearance: none;
  -webkit-appearance: none;
  cursor: pointer; }

mgt-tasks select::-ms-expand,
:host select::-ms-expand {
  display: none; }

mgt-tasks .PlannerTitle select,
:host .PlannerTitle select,
mgt-tasks .Header .PlannerTitle .PlanTitle,
:host .Header .PlannerTitle .PlanTitle {
  font-family: var(--default-font-family, "Segoe UI");
  font-size: var(--tasks-plan-title-font-size, 1.1em);
  padding: var(--tasks-plan-title-padding, 5px); }

mgt-tasks .Header .AddBar,
:host .Header .AddBar {
  display: flex; }

mgt-tasks .Header .AddBar .AddBarItem,
:host .Header .AddBar .AddBarItem {
  flex: 1 1 auto; }

mgt-tasks .Header .NewTaskDue,
:host .Header .NewTaskDue {
  display: flex; }

mgt-tasks .Header .NewTaskDue input,
:host .Header .NewTaskDue input {
  flex: 1 1 auto; }

mgt-tasks .Header .TitleCont,
:host .Header .TitleCont {
  flex: 1 1 auto;
  height: var(--tasks-new-button-height, 34px); }

mgt-tasks .Header .NewTaskButton,
:host .Header .NewTaskButton {
  flex: 0 0 auto;
  display: inline-block;
  width: var(--task-new-button-width, 90px);
  height: var(--tasks-new-button-height, 32px);
  max-width: 90px;
  min-width: 90px;
  line-height: 200%;
  text-align: center;
  align-content: center;
  align-self: center;
  vertical-align: middle;
  justify-self: flex-end;
  background: var(--tasks-new-button-background, #0078d4);
  border: var(--tasks-new-button-border, solid 1px rgba(0, 0, 0, 0));
  color: var(--tasks-new-button-color, #ffffff);
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  cursor: pointer; }

mgt-tasks .Header .NewTaskButton:hover,
:host .Header .NewTaskButton:hover {
  background: var(--tasks-new-button-hover-background, #0091ff); }

mgt-tasks .Header .NewTaskButton:active,
:host .Header .NewTaskButton:active {
  background: var(--tasks-new-button-active-background, #00508d); }

mgt-tasks .NewTaskName,
:host .NewTaskName {
  margin: var(--task-new-name-margin, 0 130px 0 0); }

mgt-tasks .Task,
:host .Task {
  display: flex;
  flex-direction: column;
  margin: var(--task-margin, 0 10px 10px 10px);
  padding: var(--task-padding, 0 0 0 0);
  box-shadow: var(--task-box-shadow, 0px 2px 8px rgba(0, 0, 0, 0.092));
  background: var(--task-background, #ffffff); }

mgt-tasks .Task.NewTask,
:host .Task.NewTask {
  flex-direction: row;
  margin: var(--task-new-margin, var(--task-margin, 0 10px 10px 10px)); }

mgt-tasks .Task.NewTask .InnerTask,
:host .Task.NewTask .InnerTask {
  flex: 1 1 auto;
  align-content: center;
  vertical-align: middle;
  margin: 0 0 0 12px; }

mgt-tasks .Task.NewTask .TaskTitle,
:host .Task.NewTask .TaskTitle {
  display: flex; }

mgt-tasks .Task.NewTask .TaskHeader,
:host .Task.NewTask .TaskHeader {
  margin: 0; }

mgt-tasks .Task.NewTask .TaskTitle input,
:host .Task.NewTask .TaskTitle input {
  flex: 1 1 auto;
  font-family: var(--default-font-family, "Segoe UI");
  margin: var(--task-new-input-margin, 16px 0 0 0);
  padding: var(--task-new-input-padding, 7px);
  font-size: var(--task-new-input-font-size, 1.2em);
  border: var(--task-new-border, none); }

mgt-tasks .Task.NewTask .TaskTitle input:active,
:host .Task.NewTask .TaskTitle input:active {
  border: var(--task-new-input-active-border, none); }

mgt-tasks .Task.NewTask hr,
:host .Task.NewTask hr {
  border: var(--task-new-line-border, solid 1px #d8d8d8);
  margin: 0; }

mgt-tasks .Task.NewTask .TaskDetails,
:host .Task.NewTask .TaskDetails {
  flex: 0 0 auto;
  margin: 14px 0 14px 4px; }

mgt-tasks .Task.NewTask .TaskDetails .TaskPeople label,
:host .Task.NewTask .TaskDetails .TaskPeople label {
  display: flex;
  align-content: center;
  align-items: center; }

mgt-tasks .Task.NewTask .TaskDetails select,
:host .Task.NewTask .TaskDetails select,
mgt-tasks .Task.NewTask .TaskDetails input,
:host .Task.NewTask .TaskDetails input {
  font-family: var(--default-font-family, "Segoe UI");
  border: var(--task-new-select-border, none); }

mgt-tasks .Task.NewTask .TaskAddCont,
:host .Task.NewTask .TaskAddCont {
  flex: 0 0 auto;
  display: flex;
  align-content: center;
  align-items: center; }

mgt-tasks .Task.NewTask .TaskAddCont .TaskAdd,
:host .Task.NewTask .TaskAddCont .TaskAdd,
mgt-tasks .Task.NewTask .TaskAddCont .TaskCancel,
:host .Task.NewTask .TaskAddCont .TaskCancel {
  height: 100%;
  max-width: 50px;
  min-width: 50px;
  flex: 1 1 auto;
  justify-content: center;
  align-items: center;
  display: flex;
  cursor: pointer;
  color: white; }

mgt-tasks .Task.NewTask .TaskAddCont .TaskAdd,
:host .Task.NewTask .TaskAddCont .TaskAdd {
  background: var(--task-new-add-button-background, #0078d4); }

mgt-tasks .Task.NewTask .TaskAddCont .TaskCancel,
:host .Task.NewTask .TaskAddCont .TaskCancel {
  font-family: 'Segoe UI';
  color: var(--task-new-cancel-button-color, gray);
  margin: 0px 20px 0px 32px; }

mgt-tasks .Task.NewTask .TaskAddCont.Disabled .TaskAdd,
:host .Task.NewTask .TaskAddCont.Disabled .TaskAdd {
  background: var(--task-new-add-button-disabled-background, #eaeaea);
  cursor: default; }

mgt-tasks .Task.NewTask .SelfAssign,
:host .Task.NewTask .SelfAssign {
  display: none; }

mgt-tasks .Task.NewTask .FakeCheckBox,
:host .Task.NewTask .FakeCheckBox {
  width: 15px;
  height: 15px;
  cursor: pointer;
  margin: 0 5px 0 5px; }

mgt-tasks .Task.NewTask .FakeCheckBox::after,
:host .Task.NewTask .FakeCheckBox::after {
  font-family: 'FabricMDL2Icons';
  content: '\uE739'; }

mgt-tasks .Task.NewTask input:checked,
:host .Task.NewTask input:checked ~ .FakeCheckBox::after {
  font-family: 'FabricMDL2Icons';
  content: '\uE73A'; }

mgt-tasks .Task .TaskDetails,
:host .Task .TaskDetails {
  margin: 0 0 16px 20px;
  color: var(--task-detail-color, #767676);
  font-size: 0.9em;
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  justify-items: flex-start;
  align-content: stretch;
  align-items: stretch; }

mgt-tasks .Task .TaskDetails input,
:host .Task .TaskDetails input,
mgt-tasks .Task .TaskDetails select,
:host .Task .TaskDetails select {
  color: var(--task-detail-color, #767676);
  font-size: 0.9em; }

mgt-tasks .Task.Complete,
:host .Task.Complete {
  background: var(--task-complete-background, #f6f6f6);
  border-color: var(--task-complete-border, #e2e2e2); }

mgt-tasks .Task.Complete .TaskHeader,
:host .Task.Complete .TaskHeader {
  color: var(--task-complete-header-color, #959595); }

mgt-tasks .Task.Complete .TaskDetails,
:host .Task.Complete .TaskDetails {
  color: var(--task-complete-detail-color #b0b0b0); }

mgt-tasks .Task.Complete .TaskDetails .TaskIcon,
:host .Task.Complete .TaskDetails .TaskIcon {
  color: var(--task-compete-detail-icon-color, #959595); }

mgt-tasks .Task .TaskDetail,
:host .Task .TaskDetail {
  align-items: center;
  align-content: center;
  display: flex; }

mgt-tasks .Task .TaskDetail svg,
:host .Task .TaskDetail svg,
mgt-tasks .Task .TaskDetail span,
:host .Task .TaskDetail span {
  vertical-align: middle; }

mgt-tasks .Task .TaskDetail svg,
:host .Task .TaskDetail svg {
  margin-right: 4px; }

mgt-tasks .Task .TaskDetail .TaskIcon,
:host .Task .TaskDetail .TaskIcon {
  margin: var(--task-detail-icon-margin 0 8px 0 0); }

mgt-tasks .Task .TaskHeader,
:host .Task .TaskHeader {
  display: flex;
  justify-content: center;
  color: var(--task-header-color, #333333);
  margin: var(--task-header-margin, 0 0 0 10px); }

mgt-tasks .Task.ReadOnly .TaskCheckCont,
:host .Task.ReadOnly .TaskCheckCont {
  cursor: default; }

mgt-tasks .Task .TaskCheckCont,
:host .Task .TaskCheckCont {
  font-family: 'FabricMDL2Icons';
  display: inline-block;
  width: 35px;
  height: 35px;
  margin: 5px;
  text-align: center;
  border-radius: 50%;
  flex: 0 0 auto;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  align-content: center;
  justify-items: center;
  justify-content: center;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none; }

mgt-tasks .Task .TaskCheckCont.Complete .TaskCheck,
:host .Task .TaskCheckCont.Complete .TaskCheck {
  background: #00b294;
  border-color: #00b294;
  display: flex;
  align-items: center;
  align-content: center;
  justify-items: center;
  justify-content: center; }

mgt-tasks .Task .TaskCheck,
:host .Task .TaskCheck {
  flex: 1 1 auto;
  font-family: 'FabricMDL2Icons';
  display: inline-block;
  width: 22px;
  height: 22px;
  text-align: center;
  border-radius: 50%;
  border: solid 1px #666666;
  flex: 0 0 auto;
  color: white;
  display: flex;
  align-items: center;
  align-content: center;
  justify-items: center;
  justify-content: center;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none; }

mgt-tasks .Task .TaskCheck.Loading,
:host .Task .TaskCheck.Loading {
  color: black;
  animation: rotateIcon 2s infinite linear; }

mgt-tasks .Task .TaskTitle,
:host .Task .TaskTitle {
  flex: 1 1 auto;
  justify-self: center;
  align-self: center;
  align-content: center;
  color: #333333; }

mgt-tasks .Task .TaskDetails .TaskDetail,
:host .Task .TaskDetails .TaskDetail {
  margin: 0 20px 0 0; }

mgt-tasks .Task .TaskDetails .TaskIcon,
:host .Task .TaskDetails .TaskIcon {
  color: #333333; }

mgt-tasks .Task .TaskDetails mgt-person,
:host .Task .TaskDetails mgt-person {
  display: inline-block; }

mgt-tasks .Task .TaskDelete,
:host .Task .TaskDelete {
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  margin: 0 10px 0 0; }

@keyframes rotateIcon {
  from {
    transform: rotate(0deg); }
  to {
    transform: rotate(360deg); } }

mgt-tasks .LoadingHeader,
:host .LoadingHeader {
  max-width: 90px;
  width: 100%;
  height: 20px;
  background: #f2f2f2; }

mgt-tasks .Task.LoadingTask .TaskCheckCont,
:host .Task.LoadingTask .TaskCheckCont {
  cursor: default; }

mgt-tasks .Task.LoadingTask .TaskCheck,
:host .Task.LoadingTask .TaskCheck {
  background: #f2f2f2;
  border-color: #f2f2f2;
  cursor: default; }

mgt-tasks .Task.LoadingTask .TaskHeader,
:host .Task.LoadingTask .TaskHeader {
  justify-content: flex-start;
  justify-items: flex-start; }

mgt-tasks .Task.LoadingTask .TaskTitle,
:host .Task.LoadingTask .TaskTitle {
  max-width: 370px;
  width: 100%;
  height: 20px;
  background: #f2f2f2; }

mgt-tasks .Task.LoadingTask .TaskDetailIcon,
:host .Task.LoadingTask .TaskDetailIcon {
  width: 16px;
  height: 16px;
  margin: 5px;
  background: #f2f2f2; }

mgt-tasks .Task.LoadingTask .TaskDetail,
:host .Task.LoadingTask .TaskDetail {
  margin-right: 8px; }

mgt-tasks .Task.LoadingTask .TaskDetailName,
:host .Task.LoadingTask .TaskDetailName {
  width: 81px;
  height: 10px;
  background: #f2f2f2; }

`], We = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host,
mgt-arrow-options {
  position: relative;
  font-family: 'Segoe UI';
  margin: 0 0 12px 0; }

:host .ArrowIcon,
mgt-arrow-options .ArrowIcon {
  font-family: 'FabricMDL2Icons';
  margin: 0 0 0 20px;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none; }

:host .Header,
mgt-arrow-options .Header {
  cursor: pointer; }

:host .Header:hover,
mgt-arrow-options .Header:hover {
  color: var(--theme-primary-color);
  background-color: var(--background-color--hover); }

:host .Menu,
mgt-arrow-options .Menu {
  position: absolute;
  left: 0;
  box-shadow: rgba(0, 0, 0, 0.08) 0px 0px 40px 5px;
  background: #ffffff;
  z-index: 1;
  display: none;
  color: black;
  white-space: nowrap; }

:host .Menu.Open,
mgt-arrow-options .Menu.Open {
  display: block; }

:host .MenuOption,
mgt-arrow-options .MenuOption {
  padding: 20px;
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  display: flex;
  align-items: center;
  justify-content: stretch;
  justify-items: stretch; }

:host .MenuOption:first,
mgt-arrow-options .MenuOption:first {
  padding: 12px 20px 20px 20px; }

:host .MenuOption:hover,
mgt-arrow-options .MenuOption:hover {
  background: #c0c0c0; }

:host .MenuOption:active,
mgt-arrow-options .MenuOption:active {
  background: #d8d8d8; }

:host .MenuOptionCheck,
mgt-arrow-options .MenuOptionCheck {
  font-family: 'FabricMDL2Icons';
  color: rgba(0, 0, 0, 0);
  margin-right: 10px; }

:host .MenuOptionCheck.CurrentValue,
mgt-arrow-options .MenuOptionCheck.CurrentValue {
  color: #0078d4; }

`]; _decorate([q("mgt-arrow-options")], function (e, t) {
        class MgtArrowOptions extends t { constructor() { super(), e(this), this._clickHandler = (e => this.open = !1) } } return {
          F: MgtArrowOptions, d: [{ kind: "get", static: !0, key: "styles", value: function styles() { return We } }, { kind: "field", decorators: [property({ type: Boolean })], key: "open", value: () => !1 }, { kind: "field", decorators: [property({ type: String })], key: "value", value: () => "" }, { kind: "field", decorators: [property({ type: Object })], key: "options", value: () => ({}) }, { kind: "field", key: "_clickHandler", value: void 0 }, { kind: "method", key: "connectedCallback", value: function connectedCallback() { _get(_getPrototypeOf(MgtArrowOptions.prototype), "connectedCallback", this).call(this), window.addEventListener("click", this._clickHandler) } }, { kind: "method", key: "disconnectedCallback", value: function disconnectedCallback() { window.removeEventListener("click", this._clickHandler), _get(_getPrototypeOf(MgtArrowOptions.prototype), "disconnectedCallback", this).call(this) } }, { kind: "method", key: "onHeaderClick", value: function onHeaderClick(e) { Object.keys(this.options).length > 1 && (e.preventDefault(), e.stopPropagation(), this.open = !this.open) } }, {
            kind: "method", key: "render", value: function render() {
              return T`
      <span class="Header" @click=${e => this.onHeaderClick(e)}>
        <span class="CurrentValue">${this.value}</span>
      </span>
      <div class=${ze({ Menu: !0, Open: this.open, Closed: !this.open })}>
        ${this.getMenuOptions()}
      </div>
    `}
          }, {
            kind: "method", key: "getMenuOptions", value: function getMenuOptions() {
              let e = Object.keys(this.options), t = this.options; return e.map(e => T`
        <div
          class="MenuOption"
          @click="${r => { this.open = !1, t[e](r) }}"
        >
          <span class=${ze({ MenuOptionCheck: !0, CurrentValue: this.value === e })}>
            \uE73E
          </span>
          <span class="MenuOptionName">${e}</span>
        </div>
      `)
            }
          }]
        }
      }, MgtBaseComponent); const Qe = [z`
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
:host([hidden]) {
  display: none; }

:host {
  display: block;
  --default-font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI",
    -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
  --theme-primary-color: #0078d7;
  --theme-dark-color: #005a9e; }

.ms-Icon {
  display: inline-block;
  font-family: "FabricMDL2Icons";
  font-style: normal;
  font-weight: normal;
  font-size: 16px;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  margin: 4px 0; }

.ms-Icon--ChevronDown::before {
  content: "\\\E70D"; }

.ms-Icon--ChevronUp::before {
  content: "\\\E70E"; }

.ms-Icon--Contact::before {
  content: "\\\E77B"; }

.ms-Icon--AddFriend::before {
  content: "\\\E8FA"; }

.ms-Icon--OutlookLogoInverse::before {
  content: "\\\EB6D"; }

/*
  Your use of the content in the files referenced here is subject to the terms of the license at http://aka.ms/fabric-assets-license
*/
:host,
mgt-dot-options {
  font-family: 'Segoe UI'; }

:host .DotIcon,
mgt-dot-options .DotIcon {
  display: inline-block;
  font-family: 'FabricMDL2Icons';
  min-width: 30px;
  min-height: 30px; }

:host .Menu,
mgt-dot-options .Menu {
  position: absolute;
  box-shadow: rgba(0, 0, 0, 0.08) 0px 0px 40px 5px;
  background: #ffffff;
  z-index: 1;
  display: none;
  color: black;
  white-space: nowrap;
  transform: translateX(-50px); }

:host .DotMenu.Open .Menu,
mgt-dot-options .DotMenu.Open .Menu {
  display: block; }

:host .DotMenu .DotItem,
mgt-dot-options .DotMenu .DotItem {
  direction: ltr;
  text-align: left;
  padding: 10px 10px 8px 10px; }

:host .DotMenu .DotItem:hover,
mgt-dot-options .DotMenu .DotItem:hover {
  background: #c0c0c0; }

:host .DotMenu .DotItem:active,
mgt-dot-options .DotMenu .DotItem:active {
  background: #d8d8d8; }

:host .DotMenu .DotItemName,
mgt-dot-options .DotMenu .DotItemName {
  direction: rtl; }

`]; _decorate([q("mgt-dot-options")], function (e, t) {
        class MgtDotOptions extends t { constructor() { super(), e(this), this._clickHandler = (e => this.open = !1) } } return {
          F: MgtDotOptions, d: [{ kind: "get", static: !0, key: "styles", value: function styles() { return Qe } }, { kind: "field", decorators: [property({ type: Boolean })], key: "open", value: () => !1 }, { kind: "field", decorators: [property({ type: Object })], key: "options", value: () => null }, { kind: "field", key: "_clickHandler", value: () => null }, { kind: "method", key: "connectedCallback", value: function connectedCallback() { _get(_getPrototypeOf(MgtDotOptions.prototype), "connectedCallback", this).call(this), window.addEventListener("click", this._clickHandler) } }, { kind: "method", key: "disconnectedCallback", value: function disconnectedCallback() { window.removeEventListener("click", this._clickHandler), _get(_getPrototypeOf(MgtDotOptions.prototype), "disconnectedCallback", this).call(this) } }, { kind: "method", key: "onDotClick", value: function onDotClick(e) { e.preventDefault(), e.stopPropagation(), this.open = !this.open } }, {
            kind: "method", key: "render", value: function render() {
              return T`
      <div class=${ze({ DotMenu: !0, Open: this.open })} @click=${e => this.onDotClick(e)}>
        <span class="DotIcon">\uE712</span>
        <div class="Menu">
          ${Object.keys(this.options).map(e => this.getMenuOption(e, this.options[e]))}
        </div>
      </div>
    `}
          }, {
            kind: "method", key: "getMenuOption", value: function getMenuOption(e, t) {
              return T`
      <div
        class="DotItem"
        @click="${e => { e.preventDefault(), e.stopPropagation(), t(e), this.open = !1 }}"
      >
        <span class="DotItemName">
          ${e}
        </span>
      </div>
    `}
          }]
        }
      }, MgtBaseComponent); const Je = { todo: { DUE_DATE_TIME: "T17:00", BASE_SELF_ASSIGNED: "All Tasks", PLANS_SELF_ASSIGNED: "All groups", BUCKETS_SELF_ASSIGNED: "All Folders", PLAN_NOT_FOUND: "Group not found", BUCKET_NOT_FOUND: "Folder not found" }, planner: { DUE_DATE_TIME: "T17:00", BASE_SELF_ASSIGNED: "Assigned to Me", PLANS_SELF_ASSIGNED: "All Plans", BUCKETS_SELF_ASSIGNED: "All Buckets", PLAN_NOT_FOUND: "Plan not found", BUCKET_NOT_FOUND: "Bucket not found" } }; let Ke = _decorate([q("mgt-tasks")], function (t, r) {
        class MgtTasks extends r { constructor() { super(), t(this), this._providerUpdateCallback = (() => this.loadTasks()) } } return {
          F: MgtTasks, d: [{ kind: "get", key: "res", value: function res() { switch (this.dataSource) { case "todo": return Je.todo; case "planner": default: return Je.planner } } }, { kind: "get", static: !0, key: "styles", value: function styles() { return Ge } }, { kind: "field", decorators: [property({ attribute: "read-only", type: Boolean })], key: "readOnly", value: () => !1 }, { kind: "field", decorators: [property({ attribute: "data-source", type: String })], key: "dataSource", value: () => "planner" }, { kind: "field", decorators: [property({ attribute: "target-id", type: String })], key: "targetId", value: () => null }, { kind: "field", decorators: [property({ attribute: "target-bucket-id", type: String })], key: "targetBucketId", value: () => null }, { kind: "field", decorators: [property({ attribute: "initial-id", type: String })], key: "initialId", value: () => null }, { kind: "field", decorators: [property({ attribute: "initial-bucket-id", type: String })], key: "initialBucketId", value: () => null }, { kind: "field", decorators: [property()], key: "_showNewTask", value: () => !1 }, { kind: "field", decorators: [property()], key: "_newTaskBeingAdded", value: () => !1 }, { kind: "field", decorators: [property()], key: "_newTaskSelfAssigned", value: () => !0 }, { kind: "field", decorators: [property()], key: "_newTaskName", value: () => "" }, { kind: "field", decorators: [property()], key: "_newTaskDueDate", value: () => "" }, { kind: "field", decorators: [property()], key: "_newTaskDresserId", value: () => "" }, { kind: "field", decorators: [property()], key: "_newTaskDrawerId", value: () => "" }, { kind: "field", decorators: [property()], key: "_dressers", value: () => [] }, { kind: "field", decorators: [property()], key: "_drawers", value: () => [] }, { kind: "field", decorators: [property()], key: "_tasks", value: () => [] }, { kind: "field", decorators: [property()], key: "_currentTargetDresser", value() { return this.res.BASE_SELF_ASSIGNED } }, { kind: "field", decorators: [property()], key: "_currentSubTargetDresser", value() { return this.res.PLANS_SELF_ASSIGNED } }, { kind: "field", decorators: [property()], key: "_currentTargetDrawer", value() { return this.res.BUCKETS_SELF_ASSIGNED } }, { kind: "field", decorators: [property()], key: "_hiddenTasks", value: () => [] }, { kind: "field", decorators: [property()], key: "_loadingTasks", value: () => [] }, { kind: "field", decorators: [property()], key: "_inTaskLoad", value: () => !1 }, { kind: "field", decorators: [property()], key: "_hasDoneInitialLoad", value: () => !1 }, { kind: "field", decorators: [property()], key: "_todoDefaultSet", value: () => !1 }, { kind: "field", key: "_me", value: () => null }, { kind: "field", key: "_providerUpdateCallback", value: void 0 }, { kind: "method", key: "connectedCallback", value: function connectedCallback() { _get(_getPrototypeOf(MgtTasks.prototype), "connectedCallback", this).call(this), Providers.onProviderUpdated(this._providerUpdateCallback) } }, { kind: "method", key: "disconnectedCallback", value: function disconnectedCallback() { Providers.removeProviderUpdatedListener(this._providerUpdateCallback), _get(_getPrototypeOf(MgtTasks.prototype), "disconnectedCallback", this).call(this) } }, { kind: "method", key: "firstUpdated", value: function firstUpdated() { !this.initialId || this._currentTargetDresser && !this.isDefault(this._currentTargetDresser) || ("planner" === this.dataSource ? this._currentTargetDresser = this.initialId : "todo" === this.dataSource && (this._currentTargetDrawer = this.initialId)), "planner" !== this.dataSource || !this.initialBucketId || this._currentTargetDrawer && !this.isDefault(this._currentTargetDrawer) || (this._currentTargetDrawer = this.initialBucketId), this.loadTasks() } }, { kind: "method", key: "attributeChangedCallback", value: function attributeChangedCallback(e, t, r) { _get(_getPrototypeOf(MgtTasks.prototype), "attributeChangedCallback", this).call(this, e, t, r), "data-source" === e && ("planner" === this.dataSource ? (this._currentTargetDresser = this.initialId || this.res.BASE_SELF_ASSIGNED, this._currentTargetDrawer = this.initialBucketId || this.res.BUCKETS_SELF_ASSIGNED) : "todo" === this.dataSource && (this._currentTargetDresser = this.res.BASE_SELF_ASSIGNED, this._currentTargetDrawer = this.initialId || this.res.BUCKETS_SELF_ASSIGNED), this._newTaskSelfAssigned = !1, this._newTaskDrawerId = "", this._newTaskDresserId = "", this._newTaskDueDate = "", this._newTaskName = "", this._newTaskBeingAdded = !1, this._tasks = [], this._drawers = [], this._dressers = [], this._hasDoneInitialLoad = !1, this._inTaskLoad = !1, this._todoDefaultSet = !1, this.loadTasks()) } }, { kind: "method", key: "loadTasks", value: async function loadTasks() { let e = this.getTaskSource(); e && (this._inTaskLoad = !0, this._me = await e.me(), this.targetId ? "todo" === this.dataSource ? await this._loadTargetTodoTasks(e) : await this._loadTargetPlannerTasks(e) : await this._loadAllTasks(e), this._inTaskLoad = !1, this._hasDoneInitialLoad || (this._hasDoneInitialLoad = !0)) } }, { kind: "method", key: "_loadTargetTodoTasks", value: async function _loadTargetTodoTasks(e) { let t = await e.getMyDressers(), r = (await Promise.all(t.map(t => e.getDrawersForDresser(t.id)))).reduce((e, t) => [...e, ...t], []), n = (await Promise.all(r.map(t => e.getAllTasksForDrawer(t.id, t.parentId)))).reduce((e, t) => [...e, ...t], []); this._tasks = n, this._drawers = r, this._dressers = t, this._currentTargetDresser = this.res.BASE_SELF_ASSIGNED, this._currentTargetDrawer = this.targetId } }, { kind: "method", key: "_loadTargetPlannerTasks", value: async function _loadTargetPlannerTasks(e) { let t = await e.getSingleDresser(this.targetId), r = await e.getDrawersForDresser(t.id), n = (await Promise.all(r.map(t => e.getAllTasksForDrawer(t.id, t.parentId)))).reduce((e, t) => [...e, ...t], []); this._tasks = n, this._drawers = r, this._dressers = [t], this._currentTargetDresser = this.targetId, this.targetBucketId && (this._currentTargetDrawer = this.targetBucketId) } }, { kind: "method", key: "_loadAllTasks", value: async function _loadAllTasks(e) { let t = await e.getMyDressers(), r = (await Promise.all(t.map(t => e.getDrawersForDresser(t.id)))).reduce((e, t) => [...e, ...t], []); if (!this.initialId && "todo" === this.dataSource && !this._todoDefaultSet) { this._todoDefaultSet = !0; let e = r.find(e => e._raw.isDefaultFolder); e && (this._currentTargetDrawer = e.id) } let n = (await Promise.all(r.map(t => e.getAllTasksForDrawer(t.id, t.parentId)))).reduce((e, t) => [...e, ...t], []); this._tasks = n, this._drawers = r, this._dressers = t } }, { kind: "method", key: "addTask", value: async function addTask(e, t, r, n, o = {}) { let i = this.getTaskSource(); if (!i) return; let s = { topParentId: r, immediateParentId: n, name: e, assignments: o }; t && "T" !== t && (s.dueDate = this.getDateTimeOffset(t + "Z")), this._newTaskBeingAdded = !0, await i.addTask(s), await this.loadTasks(), this._newTaskBeingAdded = !1, this.closeNewTask(null) } }, { kind: "method", key: "completeTask", value: async function completeTask(e) { let t = this.getTaskSource(); t && (this._loadingTasks = [...this._loadingTasks, e.id], await t.setTaskComplete(e.id, e.eTag), await this.loadTasks(), this._loadingTasks = this._loadingTasks.filter(t => t !== e.id)) } }, { kind: "method", key: "uncompleteTask", value: async function uncompleteTask(e) { let t = this.getTaskSource(); t && (this._loadingTasks = [...this._loadingTasks, e.id], await t.setTaskIncomplete(e.id, e.eTag), await this.loadTasks(), this._loadingTasks = this._loadingTasks.filter(t => t !== e.id)) } }, { kind: "method", key: "removeTask", value: async function removeTask(e) { let t = this.getTaskSource(); t && (this._hiddenTasks = [...this._hiddenTasks, e.id], await t.removeTask(e.id, e.eTag), await this.loadTasks(), this._hiddenTasks = this._hiddenTasks.filter(t => t !== e.id)) } }, { kind: "method", key: "openNewTask", value: function openNewTask(e) { this._showNewTask = !0 } }, { kind: "method", key: "closeNewTask", value: function closeNewTask(e) { this._showNewTask = !1, this._newTaskSelfAssigned = !1, this._newTaskDueDate = "", this._newTaskName = "", this._newTaskDresserId = "" } }, {
            kind: "method", key: "render", value: function render() {
              let e = this._tasks.filter(e => this.taskPlanFilter(e)).filter(e => this.taskBucketPlanFilter(e)).filter(e => !this._hiddenTasks.includes(e.id)), t = this._inTaskLoad && !this._hasDoneInitialLoad ? this.renderLoadingTask() : null; return T`
      <div class="Header">
        <span class="PlannerTitle">
          ${this.renderPlanOptions()}
        </span>
      </div>
      <div class="Tasks">
        ${this._showNewTask ? this.renderNewTaskHtml() : null} ${t}
        ${$e(e, e => e.id, e => this.renderTaskHtml(e))}
      </div>
    `}
          }, { kind: "method", key: "onAddTaskClick", value: function onAddTaskClick(e) { this._newTaskBeingAdded || !this._newTaskName || this.isDefault(this._currentTargetDresser) && !this._newTaskDresserId || this.addTask(this._newTaskName, this._newTaskDueDate ? this._newTaskDueDate + this.res.DUE_DATE_TIME : null, this.isDefault(this._currentTargetDresser) ? this._newTaskDresserId : this._currentTargetDresser, this.isDefault(this._currentTargetDrawer) ? this._newTaskDrawerId : this._currentTargetDrawer, this._newTaskSelfAssigned ? { [this._me.id]: { "@odata.type": "microsoft.graph.plannerAssignment", orderHint: "string !" } } : void 0) } }, {
            kind: "method", key: "renderPlanOptions", value: function renderPlanOptions() {
              let t = Providers.globalProvider; if (!t || t.state !== e.ProviderState.SignedIn) return null; if (this._inTaskLoad && !this._hasDoneInitialLoad) return T`
        <span class="LoadingHeader"></span>
      `; let r = this.readOnly || this._showNewTask ? null : T`
            <span
              class="AddBarItem NewTaskButton"
              @click="${e => { this._showNewTask ? this.closeNewTask(e) : this.openNewTask(e) }}"
            >
              <span class="TaskIcon">\uE710</span>
              <span>Add</span>
            </span>
          `; if ("planner" === this.dataSource) {
                let e = this._dressers.find(e => e.id === this._currentTargetDresser) || { title: this.res.BASE_SELF_ASSIGNED }, t = { [this.res.BASE_SELF_ASSIGNED]: e => { this._currentTargetDresser = this.res.BASE_SELF_ASSIGNED, this._currentTargetDrawer = this.res.BUCKETS_SELF_ASSIGNED } }; for (let e of this._dressers) t[e.title] = (t => { this._currentTargetDresser = e.id, this._currentTargetDrawer = this.res.BUCKETS_SELF_ASSIGNED }); let n = this.targetId ? T`
            <span class="PlanTitle">
              ${this._dressers[0] && this._dressers[0].title}
            </span>
          `: T`
            <mgt-arrow-options .options="${t}" .value="${e.title}"></mgt-arrow-options>
          `, o = this.isDefault(this._currentTargetDresser) ? null : T`
            <span class="TaskIcon Divider">/</span>
          `, i = this._drawers.find(e => e.id === this._currentTargetDrawer) || { name: this.res.BUCKETS_SELF_ASSIGNED }, s = { [this.res.BUCKETS_SELF_ASSIGNED]: e => { this._currentTargetDrawer = this.res.BUCKETS_SELF_ASSIGNED } }; for (let e of this._drawers.filter(e => e.parentId === this._currentTargetDresser)) s[e.name] = (t => { this._currentTargetDrawer = e.id }); let a = this.targetBucketId ? T`
            <span class="PlanTitle">
              ${this._drawers[0] && this._drawers[0].name}
            </span>
          `: T`
            <mgt-arrow-options .options="${s}" .value="${i.name}"></mgt-arrow-options>
          `; return T`
        <span class="TitleCont">
          ${n} ${o} ${this.isDefault(this._currentTargetDresser) ? null : a}
        </span>
        ${r}
      `} {
                let e = this._drawers.find(e => e.id === this.targetId) || { name: this.res.BUCKETS_SELF_ASSIGNED }, t = this._drawers.find(e => e.id === this._currentTargetDrawer) || { name: this.res.BUCKETS_SELF_ASSIGNED }, n = {}; for (let e of this._drawers) n[e.name] = (t => { this._currentTargetDrawer = e.id }); n[this.res.BUCKETS_SELF_ASSIGNED] = (e => { this._currentTargetDrawer = this.res.BUCKETS_SELF_ASSIGNED }); let o = this.targetId ? T`
            <span class="PlanTitle">
              ${e.name}
            </span>
          `: T`
            <mgt-arrow-options .value="${t.name}" .options="${n}"></mgt-arrow-options>
          `; return T`
        <span class="TitleCont">
          ${o}
        </span>
        ${r}
      `}
            }
          }, {
            kind: "method", key: "renderNewTaskHtml", value: function renderNewTaskHtml() {
              let e = T`
      <span class="TaskTitle">
        <input
          type="text"
          placeholder="Task..."
          .value="${this._newTaskName}"
          @input="${e => { this._newTaskName = e.target.value }}"
        />
      </span>
    `, t = this._dressers; t.length > 0 && !this._newTaskDresserId && (this._newTaskDresserId = t[0].id); let r = "todo" === this.dataSource ? null : this.isDefault(this._currentTargetDresser) ? T`
            <span class="TaskDetail TaskAssignee">
              ${this.renderPlannerIcon()}
              <select
                .value="${this._newTaskDresserId}"
                @change="${e => { this._newTaskDresserId = e.target.value }}"
              >
                ${this._dressers.map(e => T`
                    <option value="${e.id}">${e.title}</option>
                  `)}
              </select>
            </span>
          `: T`
            <span class="TaskDetail TaskAssignee">
              ${this.renderPlannerIcon()}
              <span>${this.getPlanTitle(this._currentTargetDresser)}</span>
            </span>
          `, n = this._drawers.filter(e => !this.isDefault(this._currentTargetDresser) && e.parentId === this._currentTargetDresser || this.isDefault(this._currentTargetDresser) && e.parentId === this._newTaskDresserId); n.length > 0 && !this._newTaskDrawerId && (this._newTaskDrawerId = n[0].id); let o = this.isDefault(this._currentTargetDrawer) ? T`
          <span class="TaskDetail TaskBucket">
            ${this.renderBucketIcon()}
            <select
              .value="${this._newTaskDrawerId}"
              @change="${e => { this._newTaskDrawerId = e.target.value }}"
            >
              ${n.map(e => T`
                  <option value="${e.id}">${e.name}</option>
                `)}
            </select>
          </span>
        `: T`
          <span class="TaskDetail TaskBucket">
            ${this.renderBucketIcon()}
            <span>${this.getDrawerName(this._currentTargetDrawer)}</span>
          </span>
        `, i = T`
      <span class="TaskDetail TaskDue">
        ${this.renderCalendarIcon()}
        <input
          type="date"
          .value="${this._newTaskDueDate}"
          @change="${e => { this._newTaskDueDate = e.target.value }}"
        />
      </span>
    `, s = "todo" === this.dataSource ? null : T`
            <span class="TaskDetail TaskPeople">
              <label>
                <input
                  class="SelfAssign"
                  type="checkbox"
                  .checked="${this._newTaskSelfAssigned}"
                  @change="${e => { this._newTaskSelfAssigned = e.target.checked }}"
                />
                <span class="FakeCheckBox"></span>
                <span>Assign to Me</span>
              </label>
            </span>
          `, a = this._newTaskBeingAdded ? T`
          <div class="TaskAddCont"></div>
        `: T`
          <div class="TaskAddCont ${"" === this._newTaskName ? "Disabled" : ""}">
            <div class="TaskIcon TaskCancel" @click="${this.closeNewTask}">
              <span>Cancel</span>
            </div>
            <div class="TaskIcon TaskAdd" @click="${this.onAddTaskClick}">
              <span>\uE710</span>
            </div>
          </div>
        `; return T`
      <div class="Task NewTask Incomplete">
        <div class="InnerTask">
          <span class="TaskHeader">
            ${e}
          </span>
          <hr />
          <span class="TaskDetails">
            ${r} ${o} ${s} ${i}
          </span>
        </div>
        ${a}
      </div>
    `}
          }, {
            kind: "method", key: "renderTaskHtml", value: function renderTaskHtml(e) {
              let { name: t = "Task", completed: r = !1, dueDate: n, assignments: o } = e, i = new Date(n), s = Object.keys(o), a = this._loadingTasks.includes(e.id) ? T`
          <span class="TaskCheck TaskIcon Loading">\uF16A</span>
        `: r ? T`
          <span class="TaskCheck TaskIcon Complete">\uE73E</span>
        `: T`
          <span class="TaskCheck TaskIcon Incomplete"></span>
        `, c = "todo" !== this.dataSource && this.isDefault(this._currentTargetDresser) ? T`
            <span class="TaskDetail TaskAssignee">
              ${this.renderPlannerIcon()}
              <span>${this.getPlanTitle(e.topParentId)}</span>
            </span>
          `: null, l = this.isDefault(this._currentTargetDrawer) ? T`
          <span class="TaskDetail TaskBucket">
            ${this.renderBucketIcon()}
            <span>${this.getDrawerName(e.immediateParentId)}</span>
          </span>
        `: null, d = n ? T`
          <span class="TaskDetail TaskDue">
            ${this.renderCalendarIcon()}
            <span>${function getShortDateString(e) { let t = e.getMonth(), r = e.getDate(); return `${function getMonthString(e) { switch (e) { case 0: return "January"; case 1: return "February"; case 2: return "March"; case 3: return "April"; case 4: return "May"; case 5: return "June"; case 6: return "July"; case 7: return "August"; case 8: return "September"; case 9: return "October"; case 10: return "November"; case 11: return "December"; default: return "Month" } }(t)} ${r}` }(i)}</span>
          </span>
        `: null, u = s && 0 !== s.length ? T`
            <span class="TaskDetail TaskPeople">
              ${s.map(e => T`
                    <mgt-person user-id="${e}"></mgt-person>
                  `)}
            </span>
          `: null, h = this.readOnly ? null : T`
          <span class="TaskIcon TaskDelete">
            <mgt-dot-options
              .options="${{ "Delete Task": () => this.removeTask(e) }}"
            ></mgt-dot-options>
          </span>
        `; return T`
      <div
        class=${ze({ Task: !0, Complete: r, Incomplete: !r, ReadOnly: this.readOnly })}
      >
        <div class="TaskHeader">
          <span
            class=${ze({ TaskCheckCont: !0, Complete: r, Incomplete: !r })}
            @click="${t => { this.readOnly || (e.completed ? this.uncompleteTask(e) : this.completeTask(e)) }}"
          >
            ${a}
          </span>
          <span class="TaskTitle">
            ${t}
          </span>
          ${h}
        </div>
        <div class="TaskDetails">
          ${c} ${l} ${u} ${d}
        </div>
      </div>
    `}
          }, {
            kind: "method", key: "renderLoadingTask", value: function renderLoadingTask() {
              return T`
      <div class="Task LoadingTask">
        <div class="TaskHeader">
          <div class="TaskCheckCont">
            <div class="TaskCheck"></div>
          </div>
          <div class="TaskTitle"></div>
        </div>
        <div class="TaskDetails">
          <div class="TaskDetail">
            <div class="TaskDetailIcon"></div>
            <div class="TaskDetailName"></div>
          </div>
          <div class="TaskDetail">
            <div class="TaskDetailIcon"></div>
            <div class="TaskDetailName"></div>
          </div>
          <div class="TaskDetail">
            <div class="TaskDetailIcon"></div>
            <div class="TaskDetailName"></div>
          </div>
          <div class="TaskDetail">
            <div class="TaskDetailIcon"></div>
            <div class="TaskDetailName"></div>
          </div>
        </div>
      </div>
    `}
          }, {
            kind: "method", key: "renderPlannerIcon", value: function renderPlannerIcon() {
              return T`
      <svg width="16" height="18" viewBox="0 0 16 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.223 1.156C6.98 1.26 6.769 1.404 6.586 1.586C6.403 1.768 6.261 1.98 6.157 2.223C6.052 2.465 6 2.724 6 3H2V17H14V3H10C10 2.724 9.948 2.465 9.844 2.223C9.74 1.98 9.596 1.768 9.414 1.586C9.231 1.404 9.02 1.26 8.777 1.156C8.535 1.053 8.276 1 8 1C7.723 1 7.465 1.053 7.223 1.156ZM5 4H7V3C7 2.86 7.026 2.729 7.078 2.609C7.13 2.49 7.202 2.385 7.293 2.293C7.384 2.202 7.49 2.131 7.609 2.079C7.73 2.026 7.859 2 8 2C8.14 2 8.271 2.026 8.39 2.079C8.511 2.131 8.616 2.202 8.707 2.293C8.798 2.385 8.87 2.49 8.922 2.609C8.974 2.729 9 2.86 9 3V4H11V5H5V4ZM12 6V4H13V16H3V4H4V6H12Z"
          fill="#3C3C3C"
        />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.35156 12.3517L5.49956 14.2037L4.14856 12.8517L4.85156 12.1487L5.49956 12.7967L6.64856 11.6487L7.35156 12.3517Z"
          fill="#3C3C3C"
        />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M7.35156 8.35168L5.49956 10.2037L4.14856 8.85168L4.85156 8.14868L5.49956 8.79668L6.64856 7.64868L7.35156 8.35168Z"
          fill="#3C3C3C"
        />
        <path fill-rule="evenodd" clip-rule="evenodd" d="M8 14H12.001V13H8V14Z" fill="#3C3C3C" />
        <path fill-rule="evenodd" clip-rule="evenodd" d="M8 10H12.001V9H8V10Z" fill="#3C3C3C" />
      </svg>
    `}
          }, {
            kind: "method", key: "renderBucketIcon", value: function renderBucketIcon() {
              return T`
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M14 2H2V4H3H5H6H10H11H13H14V2ZM10 5H6V6H10V5ZM5 5H3V14H13V5H11V6C11 6.55228 10.5523 7 10 7H6C5.44772 7 5 6.55228 5 6V5ZM1 5H2V14V15H3H13H14V14V5H15V4V2V1H14H2H1V2V4V5Z"
          fill="#3C3C3C"
        />
      </svg>
    `}
          }, {
            kind: "method", key: "renderCalendarIcon", value: function renderCalendarIcon() {
              return T`
      <svg width="20" height="18" viewBox="0 0 20 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M12 7H11V8H12V7ZM9 13H8V14H9V13ZM6 7H5V8H6V7ZM9 7H8V8H9V7ZM12 9H11V10H12V9ZM15 9H14V10H15V9ZM6 9H5V10H6V9ZM9 9H8V10H9V9ZM12 11H11V12H12V11ZM15 11H14V12H15V11ZM6 11H5V12H6V11ZM9 11H8V12H9V11ZM12 13H11V14H12V13ZM15 13H14V14H15V13ZM2 2V16H18V2H15V1H14V2H6V1H5V2H2ZM17 3V5H3V3H5V4H6V3H14V4H15V3H17ZM3 15V6H17V15H3Z"
          fill="#3C3C3C"
        />
      </svg>
    `}
          }, { kind: "method", key: "getTaskSource", value: function getTaskSource() { let t = Providers.globalProvider; return t && t.state === e.ProviderState.SignedIn ? "planner" === this.dataSource ? new PlannerTaskSource(t.graph) : "todo" === this.dataSource ? new TodoTaskSource(t.graph) : null : null } }, { kind: "method", key: "isAssignedToMe", value: function isAssignedToMe(e) { if ("todo" === this.dataSource) return !0; return Object.keys(e.assignments).includes(this._me.id) } }, { kind: "method", key: "getDateTimeOffset", value: function getDateTimeOffset(e) { let t = ((new Date).getTimezoneOffset() / 60).toString(); return t.length < 2 && (t = "0" + t), e = e.replace("Z", `-${t}:00`) } }, { kind: "method", key: "getPlanTitle", value: function getPlanTitle(e) { return this.isDefault(e) ? this.res.BASE_SELF_ASSIGNED : e === this.res.PLANS_SELF_ASSIGNED ? this.res.PLANS_SELF_ASSIGNED : (this._dressers.find(t => t.id === e) || { title: this.res.PLAN_NOT_FOUND }).title } }, { kind: "method", key: "getDrawerName", value: function getDrawerName(e) { return this.isDefault(e) ? this.res.BUCKETS_SELF_ASSIGNED : (this._drawers.find(t => t.id === e) || { name: this.res.BUCKET_NOT_FOUND }).name } }, { kind: "method", key: "isDefault", value: function isDefault(e) { for (let t in Je) for (let r in Je[t]) if (e === Je[t][r]) return !0; return !1 } }, { kind: "method", key: "taskPlanFilter", value: function taskPlanFilter(e) { return e.topParentId === this._currentTargetDresser || this.isDefault(this._currentTargetDresser) && this.isAssignedToMe(e) } }, { kind: "method", key: "taskSubPlanFilter", value: function taskSubPlanFilter(e) { return e.topParentId === this._currentSubTargetDresser || this.isDefault(this._currentSubTargetDresser) } }, { kind: "method", key: "taskBucketPlanFilter", value: function taskBucketPlanFilter(e) { return e.immediateParentId === this._currentTargetDrawer || this.isDefault(this._currentTargetDrawer) } }]
        }
      }, MgtBaseComponent); var Xe = function (e, t) { return (Xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]) })(e, t) }; function __extends(e, t) { function __() { this.constructor = e } Xe(e, t), e.prototype = null === t ? Object.create(t) : (__.prototype = t.prototype, new __) } var Ze = function () { return (Ze = Object.assign || function __assign(e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e }).apply(this, arguments) }; var Ye, et = function () { function Constants() { } return Object.defineProperty(Constants, "errorDescription", { get: function () { return "error_description" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "error", { get: function () { return "error" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "scope", { get: function () { return "scope" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "clientInfo", { get: function () { return "client_info" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "clientId", { get: function () { return "clientId" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "idToken", { get: function () { return "id_token" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "adalIdToken", { get: function () { return "adal.idtoken" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "accessToken", { get: function () { return "access_token" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "expiresIn", { get: function () { return "expires_in" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "sessionState", { get: function () { return "session_state" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "claims", { get: function () { return "claims" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "msalClientInfo", { get: function () { return "msal.client.info" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "msalError", { get: function () { return "msal.error" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "msalErrorDescription", { get: function () { return "msal.error.description" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "msalSessionState", { get: function () { return "msal.session.state" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "tokenKeys", { get: function () { return "msal.token.keys" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "accessTokenKey", { get: function () { return "msal.access.token.key" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "expirationKey", { get: function () { return "msal.expiration.key" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "stateLogin", { get: function () { return "msal.state.login" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "stateAcquireToken", { get: function () { return "msal.state.acquireToken" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "stateRenew", { get: function () { return "msal.state.renew" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "nonceIdToken", { get: function () { return "msal.nonce.idtoken" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "userName", { get: function () { return "msal.username" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "idTokenKey", { get: function () { return "msal.idtoken" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "loginRequest", { get: function () { return "msal.login.request" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "loginError", { get: function () { return "msal.login.error" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "renewStatus", { get: function () { return "msal.token.renew.status" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "urlHash", { get: function () { return "msal.urlHash" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "angularLoginRequest", { get: function () { return "msal.angular.login.request" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "msal", { get: function () { return "msal" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "no_account", { get: function () { return "NO_ACCOUNT" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "consumersUtid", { get: function () { return "9188040d-6c67-4c5b-b112-36a304b66dad" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "upn", { get: function () { return "upn" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "prompt_select_account", { get: function () { return "&prompt=select_account" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "prompt_none", { get: function () { return "&prompt=none" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "prompt", { get: function () { return "prompt" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "response_mode_fragment", { get: function () { return "&response_mode=fragment" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "resourceDelimiter", { get: function () { return "|" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "tokenRenewStatusCancelled", { get: function () { return "Canceled" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "tokenRenewStatusCompleted", { get: function () { return "Completed" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "tokenRenewStatusInProgress", { get: function () { return "In Progress" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "popUpWidth", { get: function () { return this._popUpWidth }, set: function (e) { this._popUpWidth = e }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "popUpHeight", { get: function () { return this._popUpHeight }, set: function (e) { this._popUpHeight = e }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "login", { get: function () { return "LOGIN" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "renewToken", { get: function () { return "RENEW_TOKEN" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "unknown", { get: function () { return "UNKNOWN" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "homeAccountIdentifier", { get: function () { return "homeAccountIdentifier" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "common", { get: function () { return "common" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "openidScope", { get: function () { return "openid" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "profileScope", { get: function () { return "profile" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "cacheLocationLocal", { get: function () { return "localStorage" }, enumerable: !0, configurable: !0 }), Object.defineProperty(Constants, "cacheLocationSession", { get: function () { return "sessionStorage" }, enumerable: !0, configurable: !0 }), Constants._popUpWidth = 483, Constants._popUpHeight = 600, Constants }(), tt = "msal.authority", rt = "msal.acquireTokenAccount", nt = "sid", ot = "login_hint", it = "id_token", st = "domain_hint", at = "organizations", ct = "consumers", lt = "homeAccountIdentifier", dt = "login_req", ut = "domain_req", ht = { LOGIN: "login", SELECT_ACCOUNT: "select_account", CONSENT: "consent", NONE: "none" }, pt = "1.0.0", gt = { code: "unexpected_error", desc: "Unexpected error in authentication." }, ft = function (e) { function AuthError(t, r) { var n = e.call(this, r) || this; return Object.setPrototypeOf(n, AuthError.prototype), n.errorCode = t, n.errorMessage = r, n.name = "AuthError", n } return __extends(AuthError, e), AuthError.createUnexpectedError = function (e) { return new AuthError(gt.code, gt.desc + ": " + e) }, AuthError }(Error), mt = { code: "multiple_matching_tokens", desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements like authority." }, yt = { code: "multiple_authorities", desc: "Multiple authorities found in the cache. Pass authority in the API overload." }, kt = { code: "endpoints_resolution_error", desc: "Error: could not resolve endpoints. Please check network and try again." }, vt = { code: "popup_window_error", desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser." }, wt = { code: "token_renewal_error", desc: "Token renewal operation failed due to timeout." }, Tt = { code: "invalid_id_token", desc: "Invalid ID token format." }, St = { code: "invalid_state_error", desc: "Invalid state." }, bt = { code: "nonce_mismatch_error", desc: "Nonce is not matching, Nonce received: " }, _t = { code: "login_progress_error", desc: "Login_In_Progress: Error during login call - login is already in progress." }, At = { code: "acquiretoken_progress_error", desc: "AcquireToken_In_Progress: Error during login call - login is already in progress." }, Ct = { code: "user_cancelled", desc: "User cancelled the flow." }, It = { code: "callback_error", desc: "Error occurred in token received callback function." }, Et = { code: "user_login_error", desc: "User login is required." }, Pt = { code: "user_non_existent", desc: "User object does not exist. Please call a login API." }, xt = { code: "client_info_decoding_error", desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause." }, Dt = { code: "client_info_not_populated_error", desc: "The service did not populate client_info in the response, Please verify with the service team" }, Rt = { code: "null_or_empty_id_token", desc: "The idToken is null or empty. Please review the trace to determine the root cause." }, Ot = { code: "id_token_parsing_error", desc: "ID token cannot be parsed. Please review stack trace to determine root cause." }, Ut = { code: "token_encoding_error", desc: "The token to be decoded is not encoded correctly." }, Nt = function (e) { function ClientAuthError(t, r) { var n = e.call(this, t, r) || this; return n.name = "ClientAuthError", Object.setPrototypeOf(n, ClientAuthError.prototype), n } return __extends(ClientAuthError, e), ClientAuthError.createEndpointResolutionError = function (e) { var t = kt.desc; return e && !Mt.isEmpty(e) && (t += " Details: " + e), new ClientAuthError(kt.code, t) }, ClientAuthError.createMultipleMatchingTokensInCacheError = function (e) { return new ClientAuthError(mt.code, "Cache error for scope " + e + ": " + mt.desc + ".") }, ClientAuthError.createMultipleAuthoritiesInCacheError = function (e) { return new ClientAuthError(yt.code, "Cache error for scope " + e + ": " + yt.desc + ".") }, ClientAuthError.createPopupWindowError = function (e) { var t = vt.desc; return e && !Mt.isEmpty(e) && (t += " Details: " + e), new ClientAuthError(vt.code, t) }, ClientAuthError.createTokenRenewalTimeoutError = function () { return new ClientAuthError(wt.code, wt.desc) }, ClientAuthError.createInvalidIdTokenError = function (e) { return new ClientAuthError(Tt.code, Tt.desc + " Given token: " + e) }, ClientAuthError.createInvalidStateError = function (e, t) { return new ClientAuthError(St.code, St.desc + " " + e + ", state expected : " + t + ".") }, ClientAuthError.createNonceMismatchError = function (e, t) { return new ClientAuthError(bt.code, bt.desc + " " + e + ", nonce expected : " + t + ".") }, ClientAuthError.createLoginInProgressError = function () { return new ClientAuthError(_t.code, _t.desc) }, ClientAuthError.createAcquireTokenInProgressError = function () { return new ClientAuthError(At.code, At.desc) }, ClientAuthError.createUserCancelledError = function () { return new ClientAuthError(Ct.code, Ct.desc) }, ClientAuthError.createErrorInCallbackFunction = function (e) { return new ClientAuthError(It.code, It.desc + " " + e + ".") }, ClientAuthError.createUserLoginRequiredError = function () { return new ClientAuthError(Et.code, Et.desc) }, ClientAuthError.createUserDoesNotExistError = function () { return new ClientAuthError(Pt.code, Pt.desc) }, ClientAuthError.createClientInfoDecodingError = function (e) { return new ClientAuthError(xt.code, xt.desc + " Failed with error: " + e) }, ClientAuthError.createClientInfoNotPopulatedError = function (e) { return new ClientAuthError(Dt.code, Dt.desc + " Failed with error: " + e) }, ClientAuthError.createIdTokenNullOrEmptyError = function (e) { return new ClientAuthError(Rt.code, Rt.desc + " Raw ID Token Value: " + e) }, ClientAuthError.createIdTokenParsingError = function (e) { return new ClientAuthError(Ot.code, Ot.desc + " Failed with error: " + e) }, ClientAuthError.createTokenEncodingError = function (e) { return new ClientAuthError(Ut.code, Ut.desc + " Attempted to decode: " + e) }, ClientAuthError }(ft), Mt = function () { function Utils() { } return Utils.compareAccounts = function (e, t) { return !(!e || !t) && !(!e.homeAccountIdentifier || !t.homeAccountIdentifier || e.homeAccountIdentifier !== t.homeAccountIdentifier) }, Utils.decimalToHex = function (e) { for (var t = e.toString(16); t.length < 2;)t = "0" + t; return t }, Utils.getLibraryVersion = function () { return pt }, Utils.createNewGuid = function () { var e = window.crypto; if (e && e.getRandomValues) { var t = new Uint8Array(16); return e.getRandomValues(t), t[6] |= 64, t[6] &= 79, t[8] |= 128, t[8] &= 191, Utils.decimalToHex(t[0]) + Utils.decimalToHex(t[1]) + Utils.decimalToHex(t[2]) + Utils.decimalToHex(t[3]) + "-" + Utils.decimalToHex(t[4]) + Utils.decimalToHex(t[5]) + "-" + Utils.decimalToHex(t[6]) + Utils.decimalToHex(t[7]) + "-" + Utils.decimalToHex(t[8]) + Utils.decimalToHex(t[9]) + "-" + Utils.decimalToHex(t[10]) + Utils.decimalToHex(t[11]) + Utils.decimalToHex(t[12]) + Utils.decimalToHex(t[13]) + Utils.decimalToHex(t[14]) + Utils.decimalToHex(t[15]) } for (var r = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx", n = "0123456789abcdef", o = 0, i = "", s = 0; s < 36; s++)"-" !== r[s] && "4" !== r[s] && (o = 16 * Math.random() | 0), "x" === r[s] ? i += n[o] : "y" === r[s] ? (o &= 3, i += n[o |= 8]) : i += r[s]; return i }, Utils.expiresIn = function (e) { return e || (e = "3599"), this.now() + parseInt(e, 10) }, Utils.now = function () { return Math.round((new Date).getTime() / 1e3) }, Utils.isEmpty = function (e) { return void 0 === e || !e || 0 === e.length }, Utils.decodeJwt = function (e) { if (this.isEmpty(e)) return null; var t = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/.exec(e); return !t || t.length < 4 ? null : { header: t[1], JWSPayload: t[2], JWSSig: t[3] } }, Utils.extractIdToken = function (e) { var t = this.decodeJwt(e); if (!t) return null; try { var r = t.JWSPayload, n = this.base64DecodeStringUrlSafe(r); return n ? JSON.parse(n) : null } catch (e) { } return null }, Utils.base64EncodeStringUrlSafe = function (e) { return window.btoa ? window.btoa(e) : this.encode(e) }, Utils.base64DecodeStringUrlSafe = function (e) { return e = e.replace(/-/g, "+").replace(/_/g, "/"), window.atob ? decodeURIComponent(encodeURIComponent(window.atob(e))) : decodeURIComponent(encodeURIComponent(this.decode(e))) }, Utils.encode = function (e) { var t, r, n, o, i, s, a, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", l = "", d = 0; for (e = this.utf8Encode(e); d < e.length;)o = (t = e.charCodeAt(d++)) >> 2, i = (3 & t) << 4 | (r = e.charCodeAt(d++)) >> 4, s = (15 & r) << 2 | (n = e.charCodeAt(d++)) >> 6, a = 63 & n, isNaN(r) ? s = a = 64 : isNaN(n) && (a = 64), l = l + c.charAt(o) + c.charAt(i) + c.charAt(s) + c.charAt(a); return l.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") }, Utils.utf8Encode = function (e) { e = e.replace(/\r\n/g, "\n"); for (var t = "", r = 0; r < e.length; r++) { var n = e.charCodeAt(r); n < 128 ? t += String.fromCharCode(n) : n > 127 && n < 2048 ? (t += String.fromCharCode(n >> 6 | 192), t += String.fromCharCode(63 & n | 128)) : (t += String.fromCharCode(n >> 12 | 224), t += String.fromCharCode(n >> 6 & 63 | 128), t += String.fromCharCode(63 & n | 128)) } return t }, Utils.decode = function (e) { var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", r = (e = String(e).replace(/=+$/, "")).length; if (r % 4 == 1) throw Nt.createTokenEncodingError(e); for (var n, o, i, s, a, c, l, d, u = "", h = 0; h < r; h += 4) { if (n = t.indexOf(e.charAt(h)), o = t.indexOf(e.charAt(h + 1)), i = t.indexOf(e.charAt(h + 2)), s = t.indexOf(e.charAt(h + 3)), h + 2 === r - 1) { c = (a = n << 18 | o << 12 | i << 6) >> 16 & 255, l = a >> 8 & 255, u += String.fromCharCode(c, l); break } if (h + 1 === r - 1) { c = (a = n << 18 | o << 12) >> 16 & 255, u += String.fromCharCode(c); break } c = (a = n << 18 | o << 12 | i << 6 | s) >> 16 & 255, l = a >> 8 & 255, d = 255 & a, u += String.fromCharCode(c, l, d) } return u }, Utils.deserialize = function (e) { var t, r = /\+/g, n = /([^&=]+)=([^&]*)/g, o = function (e) { return decodeURIComponent(e.replace(r, " ")) }, i = {}; for (t = n.exec(e); t;)i[o(t[1])] = o(t[2]), t = n.exec(e); return i }, Utils.isIntersectingScopes = function (e, t) { e = this.convertToLowerCase(e); for (var r = 0; r < t.length; r++)if (e.indexOf(t[r].toLowerCase()) > -1) return !0; return !1 }, Utils.containsScope = function (e, t) { return e = this.convertToLowerCase(e), t.every(function (t) { return e.indexOf(t.toString().toLowerCase()) >= 0 }) }, Utils.convertToLowerCase = function (e) { return e.map(function (e) { return e.toLowerCase() }) }, Utils.removeElement = function (e, t) { return e.filter(function (e) { return e !== t }) }, Utils.getDefaultRedirectUri = function () { return window.location.href.split("?")[0].split("#")[0] }, Utils.replaceTenantPath = function (e, t) { e = e.toLowerCase(); var r = this.GetUrlComponents(e), n = r.PathSegments; return !t || 0 === n.length || n[0] !== et.common && n[0] !== at || (n[0] = t), this.constructAuthorityUriFromObject(r, n) }, Utils.constructAuthorityUriFromObject = function (e, t) { return this.CanonicalizeUri(e.Protocol + "//" + e.HostNameAndPort + "/" + t.join("/")) }, Utils.GetUrlComponents = function (e) { if (!e) throw "Url required"; var t = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"), r = e.match(t); if (!r || r.length < 6) throw "Valid url required"; var n = { Protocol: r[1], HostNameAndPort: r[4], AbsolutePath: r[5] }, o = n.AbsolutePath.split("/"); return o = o.filter(function (e) { return e && e.length > 0 }), n.PathSegments = o, n }, Utils.CanonicalizeUri = function (e) { return e && (e = e.toLowerCase()), e && !Utils.endsWith(e, "/") && (e += "/"), e }, Utils.endsWith = function (e, t) { return !(!e || !t) && -1 !== e.indexOf(t, e.length - t.length) }, Utils.urlRemoveQueryStringParameter = function (e, t) { if (this.isEmpty(e)) return e; var r = new RegExp("(\\&" + t + "=)[^&]+"); return e = e.replace(r, ""), r = new RegExp("(" + t + "=)[^&]+&"), e = e.replace(r, ""), r = new RegExp("(" + t + "=)[^&]+"), e = e.replace(r, "") }, Utils.constructUnifiedCacheQueryParameter = function (e, t) { var r, n, o = {}; if (e) if (e.account) { var i = e.account; i.sid ? (r = nt, n = i.sid) : i.userName && (r = ot, n = i.userName) } else e.sid ? (r = nt, n = e.sid) : e.loginHint && (r = ot, n = e.loginHint); else t && (t.hasOwnProperty(et.upn) ? (r = it, n = t.upn) : (r = at, n = null)); return o = this.addSSOParameter(r, n), e && e.account && e.account.homeAccountIdentifier && (o = this.addSSOParameter(lt, e.account.homeAccountIdentifier, o)), o }, Utils.addSSOParameter = function (e, t, r) { if (r || (r = {}), !t) return r; switch (e) { case nt: r[nt] = t; break; case it: r[ot] = t, r[st] = at; break; case ot: r[ot] = t; break; case at: r[st] = at; break; case ct: r[st] = ct; break; case lt: var n = t.split("."), o = Utils.base64DecodeStringUrlSafe(n[0]), i = Utils.base64DecodeStringUrlSafe(n[1]); r[dt] = o, r[ut] = i, i === et.consumersUtid ? r[st] = ct : r[st] = at; break; case dt: r[dt] = t; break; case ut: r[ut] = t }return r }, Utils.generateQueryParametersString = function (e) { var t = null; return e && Object.keys(e).forEach(function (r) { null == t ? t = r + "=" + encodeURIComponent(e[r]) : t += "&" + r + "=" + encodeURIComponent(e[r]) }), t }, Utils.isSSOParam = function (e) { return e && (e.account || e.sid || e.loginHint) }, Utils.setResponseIdToken = function (e, t) { var r = Ze({}, e); return r.idToken = t, r.idToken.objectId ? r.uniqueId = r.idToken.objectId : r.uniqueId = r.idToken.subject, r.tenantId = r.idToken.tenantId, r }, Utils }(), Lt = function () { return function AccessTokenKey(e, t, r, n, o) { this.authority = Mt.CanonicalizeUri(e), this.clientId = t, this.scopes = r, this.homeAccountIdentifier = Mt.base64EncodeStringUrlSafe(n) + "." + Mt.base64EncodeStringUrlSafe(o) } }(), Ht = function () { return function AccessTokenValue(e, t, r, n) { this.accessToken = e, this.idToken = t, this.expiresIn = r, this.homeAccountIdentifier = n } }(), Ft = function () { function ServerRequestParameters(e, t, r, n, o, i) { this.authorityInstance = e, this.clientId = t, this.scopes = r, this.nonce = Mt.createNewGuid(), this.state = i && !Mt.isEmpty(i) ? Mt.createNewGuid() + "|" + i : Mt.createNewGuid(), this.correlationId = Mt.createNewGuid(), this.xClientSku = "MSAL.JS", this.xClientVer = Mt.getLibraryVersion(), this.responseType = n, this.redirectUri = o } return Object.defineProperty(ServerRequestParameters.prototype, "authority", { get: function () { return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null }, enumerable: !0, configurable: !0 }), ServerRequestParameters.prototype.createNavigateUrl = function (e) { var t = this.createNavigationUrlString(e), r = this.authorityInstance.AuthorizationEndpoint; return r.indexOf("?") < 0 ? r += "?" : r += "&", "" + r + t.join("&") }, ServerRequestParameters.prototype.createNavigationUrlString = function (e) { e || (e = [this.clientId]), -1 === e.indexOf(this.clientId) && e.push(this.clientId); var t = []; return t.push("response_type=" + this.responseType), this.translateclientIdUsedInScope(e), t.push("scope=" + encodeURIComponent(this.parseScope(e))), t.push("client_id=" + encodeURIComponent(this.clientId)), t.push("redirect_uri=" + encodeURIComponent(this.redirectUri)), t.push("state=" + encodeURIComponent(this.state)), t.push("nonce=" + encodeURIComponent(this.nonce)), t.push("client_info=1"), t.push("x-client-SKU=" + this.xClientSku), t.push("x-client-Ver=" + this.xClientVer), this.promptValue && t.push("prompt=" + encodeURIComponent(this.promptValue)), this.claimsValue && t.push("claims=" + encodeURIComponent(this.claimsValue)), this.queryParameters && t.push(this.queryParameters), this.extraQueryParameters && t.push(this.extraQueryParameters), t.push("client-request-id=" + encodeURIComponent(this.correlationId)), t }, ServerRequestParameters.prototype.translateclientIdUsedInScope = function (e) { var t = e.indexOf(this.clientId); t >= 0 && (e.splice(t, 1), -1 === e.indexOf("openid") && e.push("openid"), -1 === e.indexOf("profile") && e.push("profile")) }, ServerRequestParameters.prototype.parseScope = function (e) { var t = ""; if (e) for (var r = 0; r < e.length; ++r)t += r !== e.length - 1 ? e[r] + " " : e[r]; return t }, ServerRequestParameters }(), qt = function () { function ClientInfo(e) { if (!e || Mt.isEmpty(e)) return this.uid = "", void (this.utid = ""); try { var t = Mt.base64DecodeStringUrlSafe(e), r = JSON.parse(t); r && (r.hasOwnProperty("uid") && (this.uid = r.uid), r.hasOwnProperty("utid") && (this.utid = r.utid)) } catch (e) { throw Nt.createClientInfoDecodingError(e) } } return Object.defineProperty(ClientInfo.prototype, "uid", { get: function () { return this._uid ? this._uid : "" }, set: function (e) { this._uid = e }, enumerable: !0, configurable: !0 }), Object.defineProperty(ClientInfo.prototype, "utid", { get: function () { return this._utid ? this._utid : "" }, set: function (e) { this._utid = e }, enumerable: !0, configurable: !0 }), ClientInfo }(), jt = function () { return function IdToken(e) { if (Mt.isEmpty(e)) throw Nt.createIdTokenNullOrEmptyError(e); try { this.rawIdToken = e, this.decodedIdToken = Mt.extractIdToken(e), this.decodedIdToken && (this.decodedIdToken.hasOwnProperty("iss") && (this.issuer = this.decodedIdToken.iss), this.decodedIdToken.hasOwnProperty("oid") && (this.objectId = this.decodedIdToken.oid), this.decodedIdToken.hasOwnProperty("sub") && (this.subject = this.decodedIdToken.sub), this.decodedIdToken.hasOwnProperty("tid") && (this.tenantId = this.decodedIdToken.tid), this.decodedIdToken.hasOwnProperty("ver") && (this.version = this.decodedIdToken.ver), this.decodedIdToken.hasOwnProperty("preferred_username") && (this.preferredName = this.decodedIdToken.preferred_username), this.decodedIdToken.hasOwnProperty("name") && (this.name = this.decodedIdToken.name), this.decodedIdToken.hasOwnProperty("nonce") && (this.nonce = this.decodedIdToken.nonce), this.decodedIdToken.hasOwnProperty("exp") && (this.expiration = this.decodedIdToken.exp), this.decodedIdToken.hasOwnProperty("home_oid") && (this.homeObjectId = this.decodedIdToken.home_oid), this.decodedIdToken.hasOwnProperty("sid") && (this.sid = this.decodedIdToken.sid)) } catch (e) { throw Nt.createIdTokenParsingError(e) } } }(), $t = function () { return function AccessTokenCacheItem(e, t) { this.key = e, this.value = t } }(), Bt = { configurationNotSet: { code: "no_config_set", desc: "Configuration has not been set. Please call the UserAgentApplication constructor with a valid Configuration object." }, invalidCacheLocation: { code: "invalid_cache_location", desc: "The cache location provided is not valid." }, noStorageSupported: { code: "browser_storage_not_supported", desc: "localStorage and sessionStorage are not supported." }, noRedirectCallbacksSet: { code: "no_redirect_callbacks", desc: "No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/-basics." }, invalidCallbackObject: { code: "invalid_callback_object", desc: "The object passed for the callback was invalid. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/-basics." }, scopesRequired: { code: "scopes_required", desc: "Scopes are required to obtain an access token." }, emptyScopes: { code: "empty_input_scopes_error", desc: "Scopes cannot be passed as empty array." }, nonArrayScopes: { code: "nonarray_input_scopes_error", desc: "Scopes cannot be passed as non-array." }, clientScope: { code: "clientid_input_scopes_error", desc: "Client ID can only be provided as a single scope." }, invalidPrompt: { code: "invalid_prompt_value", desc: "Supported prompt values are 'login', 'select_account', 'consent' and 'none'" }, invalidAuthorityType: { code: "invalid_authority_type", desc: "The given authority is not a valid type of authority supported by MSAL. Please see here for valid authorities: <insert URL here>." }, authorityUriInsecure: { code: "authority_uri_insecure", desc: "Authority URIs must use https." }, authorityUriInvalidPath: { code: "authority_uri_invalid_path", desc: "Given authority URI is invalid." }, unsupportedAuthorityValidation: { code: "unsupported_authority_validation", desc: "The authority validation is not supported for this authority type." }, b2cAuthorityUriInvalidPath: { code: "b2c_authority_uri_invalid_path", desc: "The given URI for the B2C authority is invalid." }, claimsRequestParsingError: { code: "claims_request_parsing_error", desc: "Could not parse the given claims request object." } }, Vt = function (e) { function ClientConfigurationError(t, r) { var n = e.call(this, t, r) || this; return n.name = "ClientConfigurationError", Object.setPrototypeOf(n, ClientConfigurationError.prototype), n } return __extends(ClientConfigurationError, e), ClientConfigurationError.createNoSetConfigurationError = function () { return new ClientConfigurationError(Bt.configurationNotSet.code, "" + Bt.configurationNotSet.desc) }, ClientConfigurationError.createInvalidCacheLocationConfigError = function (e) { return new ClientConfigurationError(Bt.invalidCacheLocation.code, Bt.invalidCacheLocation.desc + " Provided value: " + e + ". Possible values are: " + et.cacheLocationLocal + ", " + et.cacheLocationSession + ".") }, ClientConfigurationError.createNoStorageSupportedError = function () { return new ClientConfigurationError(Bt.noStorageSupported.code, Bt.noStorageSupported.desc) }, ClientConfigurationError.createRedirectCallbacksNotSetError = function () { return new ClientConfigurationError(Bt.noRedirectCallbacksSet.code, Bt.noRedirectCallbacksSet.desc) }, ClientConfigurationError.createInvalidCallbackObjectError = function (e) { return new ClientConfigurationError(Bt.invalidCallbackObject.code, Bt.invalidCallbackObject.desc + " Given value for callback function: " + e) }, ClientConfigurationError.createEmptyScopesArrayError = function (e) { return new ClientConfigurationError(Bt.emptyScopes.code, Bt.emptyScopes.desc + " Given value: " + e + ".") }, ClientConfigurationError.createScopesNonArrayError = function (e) { return new ClientConfigurationError(Bt.nonArrayScopes.code, Bt.nonArrayScopes.desc + " Given value: " + e + ".") }, ClientConfigurationError.createClientIdSingleScopeError = function (e) { return new ClientConfigurationError(Bt.clientScope.code, Bt.clientScope.desc + " Given value: " + e + ".") }, ClientConfigurationError.createScopesRequiredError = function (e) { return new ClientConfigurationError(Bt.scopesRequired.code, Bt.scopesRequired.desc + " Given value: " + e) }, ClientConfigurationError.createInvalidPromptError = function (e) { return new ClientConfigurationError(Bt.invalidPrompt.code, Bt.invalidPrompt.desc + " Given value: " + e) }, ClientConfigurationError.createClaimsRequestParsingError = function (e) { return new ClientConfigurationError(Bt.claimsRequestParsingError.code, Bt.claimsRequestParsingError.desc + " Given value: " + e) }, ClientConfigurationError }(Nt), zt = function () { function Storage(e) { if (Storage.instance) return Storage.instance; if (this.cacheLocation = e, this.localStorageSupported = void 0 !== window[this.cacheLocation] && null != window[this.cacheLocation], this.sessionStorageSupported = void 0 !== window[e] && null != window[e], Storage.instance = this, !this.localStorageSupported && !this.sessionStorageSupported) throw Vt.createNoStorageSupportedError(); return Storage.instance } return Storage.prototype.setItem = function (e, t, r) { window[this.cacheLocation] && window[this.cacheLocation].setItem(e, t), r && this.setItemCookie(e, t) }, Storage.prototype.getItem = function (e, t) { return t && this.getItemCookie(e) ? this.getItemCookie(e) : window[this.cacheLocation] ? window[this.cacheLocation].getItem(e) : null }, Storage.prototype.removeItem = function (e) { if (window[this.cacheLocation]) return window[this.cacheLocation].removeItem(e) }, Storage.prototype.clear = function () { if (window[this.cacheLocation]) return window[this.cacheLocation].clear() }, Storage.prototype.getAllAccessTokens = function (e, t) { var r, n = [], o = window[this.cacheLocation]; if (o) { var i = void 0; for (i in o) if (o.hasOwnProperty(i) && i.match(e) && i.match(t)) { var s = this.getItem(i); s && (r = new $t(JSON.parse(i), JSON.parse(s)), n.push(r)) } } return n }, Storage.prototype.removeAcquireTokenEntries = function () { var e = window[this.cacheLocation]; if (e) { var t = void 0; for (t in e) if (e.hasOwnProperty(t) && (-1 !== t.indexOf(tt) || 1 !== t.indexOf(rt))) { var r = t.split(et.resourceDelimiter), n = void 0; r.length > 1 && (n = r[1]), n && !this.tokenRenewalInProgress(n) && (this.removeItem(t), this.removeItem(et.renewStatus + n), this.removeItem(et.stateLogin), this.removeItem(et.stateAcquireToken), this.setItemCookie(t, "", -1)) } } this.clearCookie() }, Storage.prototype.tokenRenewalInProgress = function (e) { var t = window[this.cacheLocation][et.renewStatus + e]; return !(!t || t !== et.tokenRenewStatusInProgress) }, Storage.prototype.resetCacheItems = function () { var e = window[this.cacheLocation]; if (e) { var t = void 0; for (t in e) e.hasOwnProperty(t) && -1 !== t.indexOf(et.msal) && this.setItem(t, ""); this.removeAcquireTokenEntries() } }, Storage.prototype.setItemCookie = function (e, t, r) { var n = e + "=" + t + ";"; r && (n += "expires=" + this.getCookieExpirationTime(r) + ";"); document.cookie = n }, Storage.prototype.getItemCookie = function (e) { for (var t = e + "=", r = document.cookie.split(";"), n = 0; n < r.length; n++) { for (var o = r[n]; " " === o.charAt(0);)o = o.substring(1); if (0 === o.indexOf(t)) return o.substring(t.length, o.length) } return "" }, Storage.prototype.getCookieExpirationTime = function (e) { var t = new Date; return new Date(t.getTime() + 24 * e * 60 * 60 * 1e3).toUTCString() }, Storage.prototype.clearCookie = function () { this.setItemCookie(et.nonceIdToken, "", -1), this.setItemCookie(et.stateLogin, "", -1), this.setItemCookie(et.loginRequest, "", -1), this.setItemCookie(et.stateAcquireToken, "", -1) }, Storage.generateAcquireTokenAccountKey = function (e, t) { return rt + et.resourceDelimiter + "" + e + et.resourceDelimiter + t }, Storage.generateAuthorityKey = function (e) { return tt + et.resourceDelimiter + "" + e }, Storage }(), Gt = function () { function Account(e, t, r, n, o, i, s) { this.accountIdentifier = e, this.homeAccountIdentifier = t, this.userName = r, this.name = n, this.idToken = o, this.sid = i, this.environment = s } return Account.createAccount = function (e, t) { var r, n = e.objectId || e.subject, o = t ? t.uid : "", i = t ? t.utid : ""; return Mt.isEmpty(o) || Mt.isEmpty(i) || (r = Mt.base64EncodeStringUrlSafe(o) + "." + Mt.base64EncodeStringUrlSafe(i)), new Account(n, r, e.preferredName, e.name, e.decodedIdToken, e.sid, e.issuer) }, Account }(), Wt = function () { function XhrClient() { } return XhrClient.prototype.sendRequestAsync = function (e, t, r) { var n = this; return new Promise(function (r, o) { var i = new XMLHttpRequest; if (i.open(t, e, !0), i.onload = function (e) { (i.status < 200 || i.status >= 300) && o(n.handleError(i.responseText)); try { var t = JSON.parse(i.responseText) } catch (e) { o(n.handleError(i.responseText)) } r(t) }, i.onerror = function (e) { o(i.status) }, "GET" !== t) throw "not implemented"; i.send() }) }, XhrClient.prototype.handleError = function (e) { var t; try { if ((t = JSON.parse(e)).error) return t.error; throw e } catch (t) { return e } }, XhrClient }(); !function (e) { e[e.Aad = 0] = "Aad", e[e.Adfs = 1] = "Adfs", e[e.B2C = 2] = "B2C" }(Ye || (Ye = {})); var Qt, Jt = function (e) { function AadAuthority(t, r) { return e.call(this, t, r) || this } return __extends(AadAuthority, e), Object.defineProperty(AadAuthority.prototype, "AadInstanceDiscoveryEndpointUrl", { get: function () { return AadAuthority.AadInstanceDiscoveryEndpoint + "?api-version=1.0&authorization_endpoint=" + this.CanonicalAuthority + "oauth2/v2.0/authorize" }, enumerable: !0, configurable: !0 }), Object.defineProperty(AadAuthority.prototype, "AuthorityType", { get: function () { return Ye.Aad }, enumerable: !0, configurable: !0 }), AadAuthority.prototype.GetOpenIdConfigurationEndpointAsync = function () { var e = this, t = new Promise(function (t, r) { return t(e.DefaultOpenIdConfigurationEndpoint) }); if (!this.IsValidationEnabled) return t; var r = this.CanonicalAuthorityUrlComponents.HostNameAndPort; return this.IsInTrustedHostList(r) ? t : (new Wt).sendRequestAsync(this.AadInstanceDiscoveryEndpointUrl, "GET", !0).then(function (e) { return e.tenant_discovery_endpoint }) }, AadAuthority.prototype.IsInTrustedHostList = function (e) { return AadAuthority.TrustedHostList[e.toLowerCase()] }, AadAuthority.AadInstanceDiscoveryEndpoint = "https://login.microsoftonline.com/common/discovery/instance", AadAuthority.TrustedHostList = { "login.windows.net": "login.windows.net", "login.chinacloudapi.cn": "login.chinacloudapi.cn", "login.cloudgovapi.us": "login.cloudgovapi.us", "login.microsoftonline.com": "login.microsoftonline.com", "login.microsoftonline.de": "login.microsoftonline.de", "login.microsoftonline.us": "login.microsoftonline.us" }, AadAuthority }(function () { function Authority(e, t) { this.IsValidationEnabled = t, this.CanonicalAuthority = e, this.validateAsUri() } return Object.defineProperty(Authority.prototype, "Tenant", { get: function () { return this.CanonicalAuthorityUrlComponents.PathSegments[0] }, enumerable: !0, configurable: !0 }), Object.defineProperty(Authority.prototype, "AuthorizationEndpoint", { get: function () { return this.validateResolved(), this.tenantDiscoveryResponse.AuthorizationEndpoint.replace("{tenant}", this.Tenant) }, enumerable: !0, configurable: !0 }), Object.defineProperty(Authority.prototype, "EndSessionEndpoint", { get: function () { return this.validateResolved(), this.tenantDiscoveryResponse.EndSessionEndpoint.replace("{tenant}", this.Tenant) }, enumerable: !0, configurable: !0 }), Object.defineProperty(Authority.prototype, "SelfSignedJwtAudience", { get: function () { return this.validateResolved(), this.tenantDiscoveryResponse.Issuer.replace("{tenant}", this.Tenant) }, enumerable: !0, configurable: !0 }), Authority.prototype.validateResolved = function () { if (!this.tenantDiscoveryResponse) throw "Please call ResolveEndpointsAsync first" }, Object.defineProperty(Authority.prototype, "CanonicalAuthority", { get: function () { return this.canonicalAuthority }, set: function (e) { this.canonicalAuthority = Mt.CanonicalizeUri(e), this.canonicalAuthorityUrlComponents = null }, enumerable: !0, configurable: !0 }), Object.defineProperty(Authority.prototype, "CanonicalAuthorityUrlComponents", { get: function () { return this.canonicalAuthorityUrlComponents || (this.canonicalAuthorityUrlComponents = Mt.GetUrlComponents(this.CanonicalAuthority)), this.canonicalAuthorityUrlComponents }, enumerable: !0, configurable: !0 }), Object.defineProperty(Authority.prototype, "DefaultOpenIdConfigurationEndpoint", { get: function () { return this.CanonicalAuthority + "v2.0/.well-known/openid-configuration" }, enumerable: !0, configurable: !0 }), Authority.prototype.validateAsUri = function () { var e; try { e = this.CanonicalAuthorityUrlComponents } catch (e) { throw Bt.invalidAuthorityType } if (!e.Protocol || "https:" !== e.Protocol.toLowerCase()) throw Bt.authorityUriInsecure; if (!e.PathSegments || e.PathSegments.length < 1) throw Bt.authorityUriInvalidPath }, Authority.prototype.DiscoverEndpoints = function (e) { return (new Wt).sendRequestAsync(e, "GET", !0).then(function (e) { return { AuthorizationEndpoint: e.authorization_endpoint, EndSessionEndpoint: e.end_session_endpoint, Issuer: e.issuer } }) }, Authority.prototype.resolveEndpointsAsync = function () { var e = this, t = ""; return this.GetOpenIdConfigurationEndpointAsync().then(function (r) { return t = r, e.DiscoverEndpoints(t) }).then(function (t) { return e.tenantDiscoveryResponse = t, e }) }, Authority }()), Kt = function (e) { function B2cAuthority(t, r) { var n = e.call(this, t, r) || this, o = Mt.GetUrlComponents(t), i = o.PathSegments; if (i.length < 3) throw Bt.b2cAuthorityUriInvalidPath; return n.CanonicalAuthority = "https://" + o.HostNameAndPort + "/" + i[0] + "/" + i[1] + "/" + i[2] + "/", n } return __extends(B2cAuthority, e), Object.defineProperty(B2cAuthority.prototype, "AuthorityType", { get: function () { return Ye.B2C }, enumerable: !0, configurable: !0 }), B2cAuthority.prototype.GetOpenIdConfigurationEndpointAsync = function () { var e = this, t = new Promise(function (t, r) { return t(e.DefaultOpenIdConfigurationEndpoint) }); return this.IsValidationEnabled ? this.IsInTrustedHostList(this.CanonicalAuthorityUrlComponents.HostNameAndPort) ? t : new Promise(function (e, t) { return t(Bt.unsupportedAuthorityValidation) }) : t }, B2cAuthority }(Jt), Xt = function () { function AuthorityFactory() { } return AuthorityFactory.DetectAuthorityFromUrl = function (e) { switch (e = Mt.CanonicalizeUri(e), Mt.GetUrlComponents(e).PathSegments[0]) { case "tfp": return Ye.B2C; case "adfs": return Ye.Adfs; default: return Ye.Aad } }, AuthorityFactory.CreateInstance = function (e, t) { if (Mt.isEmpty(e)) return null; switch (AuthorityFactory.DetectAuthorityFromUrl(e)) { case Ye.B2C: return new Kt(e, t); case Ye.Aad: return new Jt(e, t); default: throw Bt.invalidAuthorityType } }, AuthorityFactory }(); !function (e) { e[e.Error = 0] = "Error", e[e.Warning = 1] = "Warning", e[e.Info = 2] = "Info", e[e.Verbose = 3] = "Verbose" }(Qt || (Qt = {})); var Zt = function () { function Logger(e, t) { void 0 === t && (t = {}), this.level = Qt.Info; var r = t.correlationId, n = void 0 === r ? "" : r, o = t.level, i = void 0 === o ? Qt.Info : o, s = t.piiLoggingEnabled, a = void 0 !== s && s; this.localCallback = e, this.correlationId = n, this.level = i, this.piiLoggingEnabled = a } return Logger.prototype.logMessage = function (e, t, r) { if (!(e > this.level || !this.piiLoggingEnabled && r)) { var n, o = (new Date).toUTCString(); n = Mt.isEmpty(this.correlationId) ? o + ":" + Mt.getLibraryVersion() + "-" + Qt[e] + " " + t : o + ":" + this.correlationId + "-" + Mt.getLibraryVersion() + "-" + Qt[e] + " " + t, this.executeCallback(e, n, r) } }, Logger.prototype.executeCallback = function (e, t, r) { this.localCallback && this.localCallback(e, t, r) }, Logger.prototype.error = function (e) { this.logMessage(Qt.Error, e, !1) }, Logger.prototype.errorPii = function (e) { this.logMessage(Qt.Error, e, !0) }, Logger.prototype.warning = function (e) { this.logMessage(Qt.Warning, e, !1) }, Logger.prototype.warningPii = function (e) { this.logMessage(Qt.Warning, e, !0) }, Logger.prototype.info = function (e) { this.logMessage(Qt.Info, e, !1) }, Logger.prototype.infoPii = function (e) { this.logMessage(Qt.Info, e, !0) }, Logger.prototype.verbose = function (e) { this.logMessage(Qt.Verbose, e, !1) }, Logger.prototype.verbosePii = function (e) { this.logMessage(Qt.Verbose, e, !0) }, Logger }(), Yt = { clientId: "", authority: null, validateAuthority: !0, redirectUri: function () { return Mt.getDefaultRedirectUri() }, postLogoutRedirectUri: function () { return Mt.getDefaultRedirectUri() }, navigateToLoginRequestUrl: !0 }, er = { cacheLocation: "sessionStorage", storeAuthStateInCookie: !1 }, tr = { logger: new Zt(null), loadFrameTimeout: 6e3, tokenRenewalOffsetSeconds: 300, navigateFrameWait: 500 }, rr = { isAngular: !1, unprotectedResources: new Array, protectedResourceMap: new Map }; var nr = { code: "server_unavailable", desc: "Server is temporarily unavailable." }, or = { code: "unknown_server_error" }, ir = function (e) { function ServerError(t, r) { var n = e.call(this, t, r) || this; return n.name = "ServerError", Object.setPrototypeOf(n, ServerError.prototype), n } return __extends(ServerError, e), ServerError.createServerUnavailableError = function () { return new ServerError(nr.code, nr.desc) }, ServerError.createUnknownServerError = function (e) { return new ServerError(or.code, e) }, ServerError }(ft), sr = { code: "login_required" }, ar = { code: "interaction_required" }, cr = { code: "consent_required" }, lr = function (e) { function InteractionRequiredAuthError(t, r) { var n = e.call(this, t, r) || this; return n.name = "InteractionRequiredAuthError", Object.setPrototypeOf(n, InteractionRequiredAuthError.prototype), n } return __extends(InteractionRequiredAuthError, e), InteractionRequiredAuthError.createLoginRequiredAuthError = function (e) { return new InteractionRequiredAuthError(sr.code, e) }, InteractionRequiredAuthError.createInteractionRequiredAuthError = function (e) { return new InteractionRequiredAuthError(ar.code, e) }, InteractionRequiredAuthError.createConsentRequiredAuthError = function (e) { return new InteractionRequiredAuthError(cr.code, e) }, InteractionRequiredAuthError }(ir); function buildResponseStateOnly(e) { return { uniqueId: "", tenantId: "", tokenType: "", idToken: null, accessToken: "", scopes: null, expiresOn: null, account: null, accountState: e } } var dr = "https://login.microsoftonline.com/common", ur = "id_token", hr = "token", pr = "id_token token", gr = function (e, t, r) { var n = r.value; return r.value = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return this.isInIframe() ? new Promise(function () { }) : n.apply(this, e) }, r }, fr = function () { function UserAgentApplication(e) { this.authResponseCallback = null, this.tokenReceivedCallback = null, this.errorReceivedCallback = null, this.config = function buildConfiguration(e) { var t = e.auth, r = e.cache, n = void 0 === r ? {} : r, o = e.system, i = void 0 === o ? {} : o, s = e.framework, a = void 0 === s ? {} : s; return { auth: Ze({}, Yt, t), cache: Ze({}, er, n), system: Ze({}, tr, i), framework: Ze({}, rr, a) } }(e), this.redirectCallbacksSet = !1, this.logger = this.config.system.logger, this.clientId = this.config.auth.clientId, this.inCookie = this.config.cache.storeAuthStateInCookie, this.authority = this.config.auth.authority || dr, this.loginInProgress = !1, this.acquireTokenInProgress = !1; try { this.cacheStorage = new zt(this.config.cache.cacheLocation) } catch (e) { throw Vt.createInvalidCacheLocationConfigError(this.config.cache.cacheLocation) } window.openedWindows = [], window.activeRenewals = {}, window.renewStates = [], window.callbackMappedToRenewStates = {}, window.promiseMappedToRenewStates = {}, window.msal = this; var t = window.location.hash, r = this.isCallback(t); this.config.framework.isAngular || r && this.handleAuthenticationResponse(t) } return Object.defineProperty(UserAgentApplication.prototype, "authority", { get: function () { return this.authorityInstance.CanonicalAuthority }, set: function (e) { this.authorityInstance = Xt.CreateInstance(e, this.config.auth.validateAuthority) }, enumerable: !0, configurable: !0 }), UserAgentApplication.prototype.getAuthorityInstance = function () { return this.authorityInstance }, UserAgentApplication.prototype.handleRedirectCallback = function (e, t) { if (!e) throw this.redirectCallbacksSet = !1, Vt.createInvalidCallbackObjectError(e); if (t ? (this.tokenReceivedCallback = e, this.errorReceivedCallback = t, this.logger.warning("This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).")) : this.authResponseCallback = e, this.redirectCallbacksSet = !0, !this.config.framework.isAngular) { var r = this.cacheStorage.getItem(et.urlHash); r && this.processCallBack(r, null) } }, UserAgentApplication.prototype.redirectSuccessHandler = function (e) { this.errorReceivedCallback ? this.tokenReceivedCallback(e) : this.authResponseCallback && this.authResponseCallback(null, e) }, UserAgentApplication.prototype.redirectErrorHandler = function (e, t) { this.errorReceivedCallback ? this.errorReceivedCallback(e, t.accountState) : this.authResponseCallback(e, t) }, UserAgentApplication.prototype.loginRedirect = function (e) { var t = this; if (!this.redirectCallbacksSet) throw Vt.createRedirectCallbacksNotSetError(); if (this.loginInProgress) { var r = void 0; return e && (r = e.state), void this.redirectErrorHandler(Nt.createLoginInProgressError(), buildResponseStateOnly(r)) } var n = this.appendScopes(e); this.validateInputScope(n, !1); var o = this.getAccount(); if (Mt.isSSOParam(e)) this.loginRedirectHelper(o, e, n); else if (this.extractADALIdToken() && !n) { this.logger.info("ADAL's idToken exists. Extracting login information from ADAL's idToken "); var i = this.buildIDTokenRequest(e); this.silentLogin = !0, this.acquireTokenSilent(i).then(function (e) { t.silentLogin = !1, t.logger.info("Unified cache call is successful"), t.redirectCallbacksSet && t.redirectSuccessHandler(e) }, function (r) { t.silentLogin = !1, t.logger.error("Error occurred during unified cache ATS"), t.loginRedirectHelper(null, e, n) }) } else this.loginRedirectHelper(null, e, n) }, UserAgentApplication.prototype.loginRedirectHelper = function (e, t, r) { var n = this; this.loginInProgress = !0, this.authorityInstance.resolveEndpointsAsync().then(function () { var o = new Ft(n.authorityInstance, n.clientId, r, ur, n.getRedirectUri(), t.state); o = n.populateQueryParams(e, t, o); var i = n.cacheStorage.getItem(et.angularLoginRequest); i && "" !== i ? n.cacheStorage.setItem(et.angularLoginRequest, "") : i = window.location.href, n.updateCacheEntries(o, e, i); var s = o.createNavigateUrl(r) + et.response_mode_fragment; n.promptUser(s) }).catch(function (e) { var r; n.logger.warning("could not resolve endpoints"), t && (r = t.state), n.redirectErrorHandler(Nt.createEndpointResolutionError(e.toString), buildResponseStateOnly(r)) }) }, UserAgentApplication.prototype.acquireTokenRedirect = function (e) { var t = this; if (!this.redirectCallbacksSet) throw Vt.createRedirectCallbacksNotSetError(); this.validateInputScope(e.scopes, !0); var r, n = e.account || this.getAccount(); if (this.acquireTokenInProgress) { var o = void 0; return e && (o = e.state), void this.redirectErrorHandler(Nt.createAcquireTokenInProgressError(), buildResponseStateOnly(this.getAccountState(o))) } if (!n && !e.sid && !e.loginHint) throw this.logger.info("User login is required"), Nt.createUserLoginRequiredError(); var i = e.authority ? Xt.CreateInstance(e.authority, this.config.auth.validateAuthority) : this.authorityInstance; this.acquireTokenInProgress = !0, i.resolveEndpointsAsync().then(function () { var o = t.getTokenType(n, e.scopes, !1); r = new Ft(i, t.clientId, e.scopes, o, t.getRedirectUri(), e.state), t.updateCacheEntries(r, n); var s = (r = t.populateQueryParams(n, e, r)).createNavigateUrl(e.scopes) + et.response_mode_fragment; s && (t.cacheStorage.setItem(et.stateAcquireToken, r.state, t.inCookie), window.location.replace(s)) }).catch(function (r) { var n; t.logger.warning("could not resolve endpoints"), e && (n = e.state), t.redirectErrorHandler(Nt.createEndpointResolutionError(r.toString), buildResponseStateOnly(n)) }) }, UserAgentApplication.prototype.isCallback = function (e) { e = this.getHash(e); var t = Mt.deserialize(e); return t.hasOwnProperty(et.errorDescription) || t.hasOwnProperty(et.error) || t.hasOwnProperty(et.accessToken) || t.hasOwnProperty(et.idToken) }, UserAgentApplication.prototype.loginPopup = function (e) { var t = this; return new Promise(function (r, n) { if (t.loginInProgress) return n(Nt.createLoginInProgressError()); var o = t.appendScopes(e); t.validateInputScope(o, !1); var i = t.getAccount(); if (Mt.isSSOParam(e)) t.loginPopupHelper(i, e, r, n, o); else if (t.extractADALIdToken() && !o) { t.logger.info("ADAL's idToken exists. Extracting login information from ADAL's idToken "); var s = t.buildIDTokenRequest(e); t.silentLogin = !0, t.acquireTokenSilent(s).then(function (e) { t.silentLogin = !1, t.logger.info("Unified cache call is successful"), r(e) }, function (i) { t.silentLogin = !1, t.logger.error("Error occurred during unified cache ATS"), t.loginPopupHelper(null, e, r, n, o) }) } else t.loginPopupHelper(null, e, r, n, o) }) }, UserAgentApplication.prototype.loginPopupHelper = function (e, t, r, n, o) { var i = this; o || (o = [this.clientId]); var s = o.join(" ").toLowerCase(), a = this.openWindow("about:blank", "_blank", 1, this, r, n); a && (this.loginInProgress = !0, this.authorityInstance.resolveEndpointsAsync().then(function () { var c = new Ft(i.authorityInstance, i.clientId, o, ur, i.getRedirectUri(), t.state); c = i.populateQueryParams(e, t, c), i.updateCacheEntries(c, e, window.location.href), i.cacheStorage.setItem(et.loginRequest, window.location.href, i.inCookie), i.cacheStorage.setItem(et.loginError, ""), i.cacheStorage.setItem(et.nonceIdToken, c.nonce, i.inCookie), i.cacheStorage.setItem(et.msalError, ""), i.cacheStorage.setItem(et.msalErrorDescription, ""), i.setAuthorityCache(c.state, i.authority); var l = c.createNavigateUrl(o) + et.response_mode_fragment; window.renewStates.push(c.state), window.requestType = et.login, i.registerCallback(c.state, s, r, n), a && (i.logger.infoPii("Navigated Popup window to:" + l), a.location.href = l) }, function () { i.logger.info(kt.code + ":" + kt.desc), i.cacheStorage.setItem(et.msalError, kt.code), i.cacheStorage.setItem(et.msalErrorDescription, kt.desc), n && n(Nt.createEndpointResolutionError()), a && a.close() }).catch(function (e) { i.logger.warning("could not resolve endpoints"), n(Nt.createEndpointResolutionError(e.toString)) })) }, UserAgentApplication.prototype.acquireTokenPopup = function (e) { var t = this; return new Promise(function (r, n) { t.validateInputScope(e.scopes, !0); var o, i = e.scopes.join(" ").toLowerCase(), s = e.account || t.getAccount(); if (t.acquireTokenInProgress) return n(Nt.createAcquireTokenInProgressError()); if (!s && (e.sid || e.loginHint)) return t.logger.info("User login is required"), n(Nt.createUserLoginRequiredError()); t.acquireTokenInProgress = !0; var a = e.authority ? Xt.CreateInstance(e.authority, t.config.auth.validateAuthority) : t.authorityInstance, c = t.openWindow("about:blank", "_blank", 1, t, r, n); c && a.resolveEndpointsAsync().then(function () { var l = t.getTokenType(s, e.scopes, !1); o = new Ft(a, t.clientId, e.scopes, l, t.getRedirectUri(), e.state), o = t.populateQueryParams(s, e, o), t.updateCacheEntries(o, s); var d = o.createNavigateUrl(e.scopes) + et.response_mode_fragment; window.renewStates.push(o.state), window.requestType = et.renewToken, t.registerCallback(o.state, i, r, n), c && (c.location.href = d) }, function () { t.logger.info(kt.code + ":" + kt.desc), t.cacheStorage.setItem(et.msalError, kt.code), t.cacheStorage.setItem(et.msalErrorDescription, kt.desc), n && n(Nt.createEndpointResolutionError()), c && c.close() }).catch(function (e) { t.logger.warning("could not resolve endpoints"), n(Nt.createEndpointResolutionError(e.toString())) }) }) }, UserAgentApplication.prototype.openWindow = function (e, t, r, n, o, i) { var s, a = this; try { s = this.openPopup(e, t, et.popUpWidth, et.popUpHeight) } catch (e) { return n.loginInProgress = !1, n.acquireTokenInProgress = !1, this.logger.info(vt.code + ":" + vt.desc), this.cacheStorage.setItem(et.msalError, vt.code), this.cacheStorage.setItem(et.msalErrorDescription, vt.desc), i && i(Nt.createPopupWindowError()), null } window.openedWindows.push(s); var c = window.setInterval(function () { if (s && s.closed && n.loginInProgress) { if (i && i(Nt.createUserCancelledError()), window.clearInterval(c), a.config.framework.isAngular) return void a.broadcast("msal:popUpClosed", Ct.code + et.resourceDelimiter + Ct.desc); n.loginInProgress = !1, n.acquireTokenInProgress = !1 } try { var e = s.location; if (-1 !== e.href.indexOf(a.getRedirectUri()) && (window.clearInterval(c), n.loginInProgress = !1, n.acquireTokenInProgress = !1, a.logger.info("Closing popup window"), a.config.framework.isAngular)) { a.broadcast("msal:popUpHashChanged", e.hash); for (var t = 0; t < window.openedWindows.length; t++)window.openedWindows[t].close() } } catch (e) { } }, r); return s }, UserAgentApplication.prototype.openPopup = function (e, t, r, n) { try { var o = window.screenLeft ? window.screenLeft : window.screenX, i = window.screenTop ? window.screenTop : window.screenY, s = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, a = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight, c = s / 2 - r / 2 + o, l = a / 2 - n / 2 + i, d = window.open(e, t, "width=" + r + ", height=" + n + ", top=" + l + ", left=" + c); if (!d) throw Nt.createPopupWindowError(); return d.focus && d.focus(), d } catch (e) { throw this.logger.error("error opening popup " + e.message), this.loginInProgress = !1, this.acquireTokenInProgress = !1, Nt.createPopupWindowError(e.toString()) } }, UserAgentApplication.prototype.acquireTokenSilent = function (e) { var t = this; return new Promise(function (r, n) { t.validateInputScope(e.scopes, !0); var o = e.scopes.join(" ").toLowerCase(), i = e.account || t.getAccount(), s = t.cacheStorage.getItem(et.adalIdToken); if (!i && (e.sid || e.loginHint) && Mt.isEmpty(s)) return t.logger.info("User login is required"), n(Nt.createUserLoginRequiredError()); var a = t.getTokenType(i, e.scopes, !0), c = new Ft(Xt.CreateInstance(e.authority, t.config.auth.validateAuthority), t.clientId, e.scopes, a, t.getRedirectUri(), e.state); if (Mt.isSSOParam(e) || i) c = t.populateQueryParams(i, e, c); else if (!i && !Mt.isEmpty(s)) { var l = Mt.extractIdToken(s); t.logger.verbose("ADAL's idToken exists. Extracting login information from ADAL's idToken "), c = t.populateQueryParams(i, null, c, l) } var d, u, h = e.claimsRequest || c.claimsValue; if (!h) try { u = t.getCachedToken(c, i) } catch (e) { d = e } return u ? (t.logger.info("Token is already in cache for scope:" + o), r(u), null) : d ? (t.logger.infoPii(d.errorCode + ":" + d.errorMessage), n(d), null) : (h ? t.logger.verbose("Skipped cache lookup since claims were given.") : t.logger.verbose("Token is not in cache for scope:" + o), c.authorityInstance || (c.authorityInstance = e.authority ? Xt.CreateInstance(e.authority, t.config.auth.validateAuthority) : t.authorityInstance), c.authorityInstance.resolveEndpointsAsync().then(function () { window.activeRenewals[o] ? (t.logger.verbose("Renew token for scope: " + o + " is in progress. Registering callback"), t.registerCallback(window.activeRenewals[o], o, r, n)) : e.scopes && e.scopes.indexOf(t.clientId) > -1 && 1 === e.scopes.length ? (t.logger.verbose("renewing idToken"), t.renewIdToken(e.scopes, r, n, i, c)) : (t.logger.verbose("renewing accesstoken"), t.renewToken(e.scopes, r, n, i, c)) }).catch(function (e) { return t.logger.warning("could not resolve endpoints"), n(Nt.createEndpointResolutionError(e.toString())), null })) }) }, UserAgentApplication.prototype.isInIframe = function () { return window.parent !== window }, UserAgentApplication.prototype.parentIsMsal = function () { return window.parent !== window && window.parent.msal }, UserAgentApplication.prototype.isInteractionRequired = function (e) { return -1 !== e.indexOf("interaction_required") || -1 !== e.indexOf("consent_required") || -1 !== e.indexOf("login_required") }, UserAgentApplication.prototype.loadIframeTimeout = function (e, t, r) { var n = this, o = window.activeRenewals[r]; this.logger.verbose("Set loading state to pending for: " + r + ":" + o), this.cacheStorage.setItem(et.renewStatus + o, et.tokenRenewStatusInProgress), this.loadFrame(e, t), setTimeout(function () { n.cacheStorage.getItem(et.renewStatus + o) === et.tokenRenewStatusInProgress && (n.logger.verbose("Loading frame has timed out after: " + n.config.system.loadFrameTimeout / 1e3 + " seconds for scope " + r + ":" + o), o && window.callbackMappedToRenewStates[o] && window.callbackMappedToRenewStates[o](null, Nt.createTokenRenewalTimeoutError()), n.cacheStorage.setItem(et.renewStatus + o, et.tokenRenewStatusCancelled)) }, this.config.system.loadFrameTimeout) }, UserAgentApplication.prototype.loadFrame = function (e, t) { var r = this; this.logger.info("LoadFrame: " + t); var n = t; setTimeout(function () { var o = r.addHiddenIFrame(n); "" !== o.src && "about:blank" !== o.src || (o.src = e, r.logger.infoPii("Frame Name : " + t + " Navigated to: " + e)) }, this.config.system.navigateFrameWait) }, UserAgentApplication.prototype.addHiddenIFrame = function (e) { if (void 0 === e) return null; this.logger.info("Add msal frame to document:" + e); var t = document.getElementById(e); if (!t) { if (document.createElement && document.documentElement && -1 === window.navigator.userAgent.indexOf("MSIE 5.0")) { var r = document.createElement("iframe"); r.setAttribute("id", e), r.style.visibility = "hidden", r.style.position = "absolute", r.style.width = r.style.height = "0", r.style.border = "0", t = document.getElementsByTagName("body")[0].appendChild(r) } else document.body && document.body.insertAdjacentHTML && document.body.insertAdjacentHTML("beforeend", "<iframe name='" + e + "' id='" + e + "' style='display:none'></iframe>"); window.frames && window.frames[e] && (t = window.frames[e]) } return t }, UserAgentApplication.prototype.addHintParameters = function (e, t, r) { var n = e || this.getAccount(); return n && (n.sid && r.promptValue === ht.NONE ? t[nt] || t[ot] || (t = Mt.addSSOParameter(nt, n.sid, t)) : t[ot] || !n.userName || Mt.isEmpty(n.userName) || (t = Mt.addSSOParameter(ot, n.userName, t)), t[ut] || t[dt] || (t = Mt.addSSOParameter(lt, n.homeAccountIdentifier, t))), t }, UserAgentApplication.prototype.promptUser = function (e) { if (!e || Mt.isEmpty(e)) throw this.logger.info("Navigate url is empty"), ft.createUnexpectedError("Navigate url is empty"); this.logger.infoPii("Navigate to:" + e), window.location.replace(e) }, UserAgentApplication.prototype.registerCallback = function (e, t, r, n) { var o = this; window.activeRenewals[t] = e, window.promiseMappedToRenewStates[e] || (window.promiseMappedToRenewStates[e] = []), window.promiseMappedToRenewStates[e].push({ resolve: r, reject: n }), window.callbackMappedToRenewStates[e] || (window.callbackMappedToRenewStates[e] = function (r, n) { window.activeRenewals[t] = null; for (var i = 0; i < window.promiseMappedToRenewStates[e].length; ++i)try { if (n) window.promiseMappedToRenewStates[e][i].reject(n); else { if (!r) throw ft.createUnexpectedError("Error and response are both null"); window.promiseMappedToRenewStates[e][i].resolve(r) } } catch (e) { o.logger.warning(e) } window.promiseMappedToRenewStates[e] = null, window.callbackMappedToRenewStates[e] = null }) }, UserAgentApplication.prototype.logout = function () { this.clearCache(), this.account = null; var e = ""; this.getPostLogoutRedirectUri() && (e = "post_logout_redirect_uri=" + encodeURIComponent(this.getPostLogoutRedirectUri())); var t = this.authority + "oauth2/v2.0/logout?" + e; this.promptUser(t) }, UserAgentApplication.prototype.clearCache = function () { window.renewStates = []; for (var e = this.cacheStorage.getAllAccessTokens(et.clientId, et.homeAccountIdentifier), t = 0; t < e.length; t++)this.cacheStorage.removeItem(JSON.stringify(e[t].key)); this.cacheStorage.resetCacheItems(), this.cacheStorage.clearCookie() }, UserAgentApplication.prototype.clearCacheForScope = function (e) { for (var t = this.cacheStorage.getAllAccessTokens(et.clientId, et.homeAccountIdentifier), r = 0; r < t.length; r++) { var n = t[r]; n.value.accessToken === e && this.cacheStorage.removeItem(JSON.stringify(n.key)) } }, UserAgentApplication.prototype.processCallBack = function (e, t, r) { var n, o; this.logger.info("Processing the callback from redirect response"), t || (t = this.getResponseState(e)); try { n = this.saveTokenFromHash(e, t) } catch (e) { o = e } this.cacheStorage.removeItem(et.urlHash); try { this.cacheStorage.clearCookie(); var i = this.getAccountState(t.state); if (n) { if (t.requestType === et.renewToken || n.accessToken ? (window.parent !== window ? this.logger.verbose("Window is in iframe, acquiring token silently") : this.logger.verbose("acquiring token interactive in progress"), n.tokenType = et.accessToken) : t.requestType === et.login && (n.tokenType = et.idToken), !r) return void this.redirectSuccessHandler(n) } else if (!r) return void this.redirectErrorHandler(o, buildResponseStateOnly(i)); r(n, o) } catch (e) { throw this.logger.error("Error occurred in token received callback function: " + e), Nt.createErrorInCallbackFunction(e.toString()) } }, UserAgentApplication.prototype.handleAuthenticationResponse = function (e) { null == e && (e = window.location.hash); var t = null, r = !1, n = !1; try { n = window.opener && window.opener.msal && window.opener.msal !== window.msal } catch (e) { n = !1 } n ? (t = window.opener.msal, r = !0) : window.parent && window.parent.msal && (t = window.parent.msal); var o = t.getResponseState(e), i = null; if (t.logger.info("Returned from redirect url"), this.parentIsMsal()) i = window.parent.callbackMappedToRenewStates[o.state]; else if (n) i = window.opener.callbackMappedToRenewStates[o.state]; else { if (i = null, t.config.auth.navigateToLoginRequestUrl) return t.cacheStorage.setItem(et.urlHash, e), void (window.parent !== window || r || (window.location.href = t.cacheStorage.getItem(et.loginRequest, t.inCookie))); if (window.location.hash = "", !this.redirectCallbacksSet) return } if (t.processCallBack(e, o, i), n) for (var s = 0; s < window.opener.openedWindows.length; s++)window.opener.openedWindows[s].close() }, UserAgentApplication.prototype.deserializeHash = function (e) { return e = this.getHash(e), Mt.deserialize(e) }, UserAgentApplication.prototype.getResponseState = function (e) { var t, r = this.deserializeHash(e); if (!r) throw ft.createUnexpectedError("Hash was not parsed correctly."); if (!r.hasOwnProperty("state")) throw ft.createUnexpectedError("Hash does not contain state."); if ((t = { requestType: et.unknown, state: r.state, stateMatch: !1 }).state === this.cacheStorage.getItem(et.stateLogin, this.inCookie) || t.state === this.silentAuthenticationState) return t.requestType = et.login, t.stateMatch = !0, t; if (t.state === this.cacheStorage.getItem(et.stateAcquireToken, this.inCookie)) return t.requestType = et.renewToken, t.stateMatch = !0, t; if (!t.stateMatch) { t.requestType = window.requestType; for (var n = window.renewStates, o = 0; o < n.length; o++)if (n[o] === t.state) { t.stateMatch = !0; break } } return t }, UserAgentApplication.prototype.getCachedToken = function (e, t) { var r = null, n = e.scopes, o = this.cacheStorage.getAllAccessTokens(this.clientId, t ? t.homeAccountIdentifier : null); if (0 === o.length) return null; var i = []; if (e.authority) { for (s = 0; s < o.length; s++) { c = (a = o[s]).key.scopes.split(" "); Mt.containsScope(c, n) && Mt.CanonicalizeUri(a.key.authority) === e.authority && i.push(a) } if (0 === i.length) return null; if (1 !== i.length) throw Nt.createMultipleMatchingTokensInCacheError(n.toString()); r = i[0] } else { for (var s = 0; s < o.length; s++) { var a, c = (a = o[s]).key.scopes.split(" "); Mt.containsScope(c, n) && i.push(a) } if (1 === i.length) r = i[0], e.authorityInstance = Xt.CreateInstance(r.key.authority, this.config.auth.validateAuthority); else { if (i.length > 1) throw Nt.createMultipleMatchingTokensInCacheError(n.toString()); var l = this.getUniqueAuthority(o, "authority"); if (l.length > 1) throw Nt.createMultipleAuthoritiesInCacheError(n.toString()); e.authorityInstance = Xt.CreateInstance(l[0], this.config.auth.validateAuthority) } } if (null != r) { var d = Number(r.value.expiresIn), u = this.config.system.tokenRenewalOffsetSeconds || 300; if (d && d > Mt.now() + u) { var h = new jt(r.value.idToken); if (!t && !(t = this.getAccount())) throw ft.createUnexpectedError("Account should not be null here."); var p = this.getAccountState(e.state), g = { uniqueId: "", tenantId: "", tokenType: r.value.idToken === r.value.accessToken ? et.idToken : et.accessToken, idToken: h, accessToken: r.value.accessToken, scopes: r.key.scopes.split(" "), expiresOn: new Date(1e3 * d), account: t, accountState: p }; return Mt.setResponseIdToken(g, h), g } return this.cacheStorage.removeItem(JSON.stringify(i[0].key)), null } return null }, UserAgentApplication.prototype.getUniqueAuthority = function (e, t) { var r = [], n = []; return e.forEach(function (e) { e.key.hasOwnProperty(t) && -1 === n.indexOf(e.key[t]) && (n.push(e.key[t]), r.push(e.key[t])) }), r }, UserAgentApplication.prototype.extractADALIdToken = function () { var e = this.cacheStorage.getItem(et.adalIdToken); return Mt.isEmpty(e) ? null : Mt.extractIdToken(e) }, UserAgentApplication.prototype.renewToken = function (e, t, r, n, o) { var i = e.join(" ").toLowerCase(); this.logger.verbose("renewToken is called for scope:" + i); var s = this.addHiddenIFrame("msalRenewFrame" + i); this.updateCacheEntries(o, n), this.logger.verbose("Renew token Expected state: " + o.state); var a = Mt.urlRemoveQueryStringParameter(o.createNavigateUrl(e), et.prompt) + et.prompt_none; window.renewStates.push(o.state), window.requestType = et.renewToken, this.registerCallback(o.state, i, t, r), this.logger.infoPii("Navigate to:" + a), s.src = "about:blank", this.loadIframeTimeout(a, "msalRenewFrame" + i, i) }, UserAgentApplication.prototype.renewIdToken = function (e, t, r, n, o) { this.logger.info("renewidToken is called"); var i = this.addHiddenIFrame("msalIdTokenFrame"); this.updateCacheEntries(o, n), this.logger.verbose("Renew Idtoken Expected state: " + o.state); var s = Mt.urlRemoveQueryStringParameter(o.createNavigateUrl(e), et.prompt) + et.prompt_none; this.silentLogin ? (window.requestType = et.login, this.silentAuthenticationState = o.state) : (window.requestType = et.renewToken, window.renewStates.push(o.state)), this.registerCallback(o.state, this.clientId, t, r), this.logger.infoPii("Navigate to:" + s), i.src = "about:blank", this.loadIframeTimeout(s, "msalIdTokenFrame", this.clientId) }, UserAgentApplication.prototype.saveAccessToken = function (e, t, r, n) { var o, i = Ze({}, e), s = new qt(n); if (r.hasOwnProperty("scope")) { for (var a = (o = r.scope).split(" "), c = this.cacheStorage.getAllAccessTokens(this.clientId, t), l = 0; l < c.length; l++) { var d = c[l]; if (d.key.homeAccountIdentifier === e.account.homeAccountIdentifier) { var u = d.key.scopes.split(" "); Mt.isIntersectingScopes(u, a) && this.cacheStorage.removeItem(JSON.stringify(d.key)) } } var h = Mt.expiresIn(r[et.expiresIn]).toString(), p = new Lt(t, this.clientId, o, s.uid, s.utid), g = new Ht(r[et.accessToken], e.idToken.rawIdToken, h, n); this.cacheStorage.setItem(JSON.stringify(p), JSON.stringify(g)), i.accessToken = r[et.accessToken], i.scopes = a, (f = Number(h)) ? i.expiresOn = new Date(1e3 * (Mt.now() + f)) : this.logger.error("Could not parse expiresIn parameter. Given value: " + h) } else { o = this.clientId; var f; p = new Lt(t, this.clientId, o, s.uid, s.utid), g = new Ht(r[et.idToken], r[et.idToken], e.idToken.expiration, n); this.cacheStorage.setItem(JSON.stringify(p), JSON.stringify(g)), i.scopes = [o], i.accessToken = r[et.idToken], (f = Number(e.idToken.expiration)) ? i.expiresOn = new Date(1e3 * f) : this.logger.error("Could not parse expiresIn parameter") } return i }, UserAgentApplication.prototype.saveTokenFromHash = function (e, t) { this.logger.info("State status:" + t.stateMatch + "; Request type:" + t.requestType), this.cacheStorage.setItem(et.msalError, ""), this.cacheStorage.setItem(et.msalErrorDescription, ""); var r, n = { uniqueId: "", tenantId: "", tokenType: "", idToken: null, accessToken: null, scopes: [], expiresOn: null, account: null, accountState: "" }, o = this.deserializeHash(e), i = "", s = ""; if (o.hasOwnProperty(et.errorDescription) || o.hasOwnProperty(et.error)) { if (this.logger.infoPii("Error :" + o[et.error] + "; Error description:" + o[et.errorDescription]), this.cacheStorage.setItem(et.msalError, o[et.error]), this.cacheStorage.setItem(et.msalErrorDescription, o[et.errorDescription]), t.requestType === et.login && (this.loginInProgress = !1, this.cacheStorage.setItem(et.loginError, o[et.errorDescription] + ":" + o[et.error]), i = zt.generateAuthorityKey(t.state)), t.requestType === et.renewToken) { this.acquireTokenInProgress = !1, i = zt.generateAuthorityKey(t.state); var a = this.getAccount(), c = void 0; c = a && !Mt.isEmpty(a.homeAccountIdentifier) ? a.homeAccountIdentifier : et.no_account, s = zt.generateAcquireTokenAccountKey(c, t.state) } r = this.isInteractionRequired(o[et.errorDescription]) ? new lr(o[et.error], o[et.errorDescription]) : new ir(o[et.error], o[et.errorDescription]) } else if (t.stateMatch) { this.logger.info("State is right"), o.hasOwnProperty(et.sessionState) && this.cacheStorage.setItem(et.msalSessionState, o[et.sessionState]), n.accountState = this.getAccountState(t.state); var l = ""; if (o.hasOwnProperty(et.accessToken)) { this.logger.info("Fragment has access token"), this.acquireTokenInProgress = !1, o.hasOwnProperty(et.idToken) ? n.idToken = new jt(o[et.idToken]) : n = Mt.setResponseIdToken(n, new jt(this.cacheStorage.getItem(et.idTokenKey))); var d = zt.generateAuthorityKey(t.state), u = this.cacheStorage.getItem(d, this.inCookie); if (Mt.isEmpty(u) || (u = Mt.replaceTenantPath(u, n.tenantId)), !o.hasOwnProperty(et.clientInfo)) throw this.logger.warning("ClientInfo not received in the response from AAD"), Nt.createClientInfoNotPopulatedError("ClientInfo not received in the response from the server"); l = o[et.clientInfo], n.account = Gt.createAccount(n.idToken, new qt(l)); var h = void 0; h = n.account && !Mt.isEmpty(n.account.homeAccountIdentifier) ? n.account.homeAccountIdentifier : et.no_account, s = zt.generateAcquireTokenAccountKey(h, t.state); var p = zt.generateAcquireTokenAccountKey(et.no_account, t.state), g = this.cacheStorage.getItem(s), f = void 0; Mt.isEmpty(g) ? Mt.isEmpty(this.cacheStorage.getItem(p)) || (n = this.saveAccessToken(n, u, o, l)) : (f = JSON.parse(g), n.account && f && Mt.compareAccounts(n.account, f) ? (n = this.saveAccessToken(n, u, o, l), this.logger.info("The user object received in the response is the same as the one passed in the acquireToken request")) : this.logger.warning("The account object created from the response is not the same as the one passed in the acquireToken request")) } if (o.hasOwnProperty(et.idToken)) { this.logger.info("Fragment has id token"), this.loginInProgress = !1, n = Mt.setResponseIdToken(n, new jt(o[et.idToken])), o.hasOwnProperty(et.clientInfo) ? l = o[et.clientInfo] : this.logger.warning("ClientInfo not received in the response from AAD"), i = zt.generateAuthorityKey(t.state); u = this.cacheStorage.getItem(i, this.inCookie); Mt.isEmpty(u) || (u = Mt.replaceTenantPath(u, n.idToken.tenantId)), this.account = Gt.createAccount(n.idToken, new qt(l)), n.account = this.account, n.idToken && n.idToken.nonce ? n.idToken.nonce !== this.cacheStorage.getItem(et.nonceIdToken, this.inCookie) ? (this.account = null, this.cacheStorage.setItem(et.loginError, "Nonce Mismatch. Expected Nonce: " + this.cacheStorage.getItem(et.nonceIdToken, this.inCookie) + ",Actual Nonce: " + n.idToken.nonce), this.logger.error("Nonce Mismatch.Expected Nonce: " + this.cacheStorage.getItem(et.nonceIdToken, this.inCookie) + ",Actual Nonce: " + n.idToken.nonce), r = Nt.createNonceMismatchError(this.cacheStorage.getItem(et.nonceIdToken, this.inCookie), n.idToken.nonce)) : (this.cacheStorage.setItem(et.idTokenKey, o[et.idToken]), this.cacheStorage.setItem(et.msalClientInfo, l), this.saveAccessToken(n, u, o, l)) : (i = t.state, s = t.state, this.logger.error("Invalid id_token received in the response"), r = Nt.createInvalidIdTokenError(n.idToken), this.cacheStorage.setItem(et.msalError, r.errorCode), this.cacheStorage.setItem(et.msalErrorDescription, r.errorMessage)) } } else { i = t.state, s = t.state; var m = this.cacheStorage.getItem(et.stateLogin, this.inCookie); this.logger.error("State Mismatch.Expected State: " + m + ",Actual State: " + t.state), r = Nt.createInvalidStateError(t.state, m), this.cacheStorage.setItem(et.msalError, r.errorCode), this.cacheStorage.setItem(et.msalErrorDescription, r.errorMessage) } if (this.cacheStorage.setItem(et.renewStatus + t.state, et.tokenRenewStatusCompleted), this.cacheStorage.removeAcquireTokenEntries(), this.inCookie && (this.cacheStorage.setItemCookie(i, "", -1), this.cacheStorage.clearCookie()), r) throw r; if (!n) throw ft.createUnexpectedError("Response is null"); return n }, UserAgentApplication.prototype.getAccount = function () { if (this.account) return this.account; var e = this.cacheStorage.getItem(et.idTokenKey), t = this.cacheStorage.getItem(et.msalClientInfo); if (!Mt.isEmpty(e) && !Mt.isEmpty(t)) { var r = new jt(e), n = new qt(t); return this.account = Gt.createAccount(r, n), this.account } return null }, UserAgentApplication.prototype.getAccountState = function (e) { if (e) { var t = e.indexOf("|"); if (t > -1 && t + 1 < e.length) return e.substring(t + 1) } return e }, UserAgentApplication.prototype.getAllAccounts = function () { for (var e = [], t = this.cacheStorage.getAllAccessTokens(et.clientId, et.homeAccountIdentifier), r = 0; r < t.length; r++) { var n = new jt(t[r].value.idToken), o = new qt(t[r].value.homeAccountIdentifier), i = Gt.createAccount(n, o); e.push(i) } return this.getUniqueAccounts(e) }, UserAgentApplication.prototype.getUniqueAccounts = function (e) { if (!e || e.length <= 1) return e; for (var t = [], r = [], n = 0; n < e.length; ++n)e[n].homeAccountIdentifier && -1 === t.indexOf(e[n].homeAccountIdentifier) && (t.push(e[n].homeAccountIdentifier), r.push(e[n])); return r }, UserAgentApplication.prototype.validateInputScope = function (e, t) { if (e) { if (!Array.isArray(e)) throw Vt.createScopesNonArrayError(e); if (e.length < 1) throw Vt.createEmptyScopesArrayError(e.toString()); if (e.indexOf(this.clientId) > -1 && e.length > 1) throw Vt.createClientIdSingleScopeError(e.toString()) } else if (t) throw Vt.createScopesRequiredError(e) }, UserAgentApplication.prototype.getScopeFromState = function (e) { if (e) { var t = e.indexOf("|"); if (t > -1 && t + 1 < e.length) return e.substring(t + 1) } return "" }, UserAgentApplication.prototype.appendScopes = function (e) { var t; return e && e.scopes && (t = e.extraScopesToConsent ? e.scopes.concat(e.extraScopesToConsent) : e.scopes), t }, UserAgentApplication.prototype.broadcast = function (e, t) { var r = new CustomEvent(e, { detail: t }); window.dispatchEvent(r) }, UserAgentApplication.prototype.getCachedTokenInternal = function (e, t, r) { var n = t || this.getAccount(); if (!n) return null; var o = this.authorityInstance ? this.authorityInstance : Xt.CreateInstance(this.authority, this.config.auth.validateAuthority), i = this.getTokenType(n, e, !0), s = new Ft(o, this.clientId, e, i, this.getRedirectUri(), r); return this.getCachedToken(s, t) }, UserAgentApplication.prototype.getScopesForEndpoint = function (e) { if (this.config.framework.unprotectedResources.length > 0) for (var t = 0; t < this.config.framework.unprotectedResources.length; t++)if (e.indexOf(this.config.framework.unprotectedResources[t]) > -1) return null; if (this.config.framework.protectedResourceMap.size > 0) for (var r = 0, n = Array.from(this.config.framework.protectedResourceMap.keys()); r < n.length; r++) { var o = n[r]; if (e.indexOf(o) > -1) return this.config.framework.protectedResourceMap.get(o) } return e.indexOf("http://") > -1 || e.indexOf("https://") > -1 ? this.getHostFromUri(e) === this.getHostFromUri(this.getRedirectUri()) ? new Array(this.clientId) : null : new Array(this.clientId) }, UserAgentApplication.prototype.getLoginInProgress = function () { return !!this.cacheStorage.getItem(et.urlHash) || this.loginInProgress }, UserAgentApplication.prototype.setloginInProgress = function (e) { this.loginInProgress = e }, UserAgentApplication.prototype.getAcquireTokenInProgress = function () { return this.acquireTokenInProgress }, UserAgentApplication.prototype.setAcquireTokenInProgress = function (e) { this.acquireTokenInProgress = e }, UserAgentApplication.prototype.getLogger = function () { return this.config.system.logger }, UserAgentApplication.prototype.getRedirectUri = function () { return "function" == typeof this.config.auth.redirectUri ? this.config.auth.redirectUri() : this.config.auth.redirectUri }, UserAgentApplication.prototype.getPostLogoutRedirectUri = function () { return "function" == typeof this.config.auth.postLogoutRedirectUri ? this.config.auth.postLogoutRedirectUri() : this.config.auth.postLogoutRedirectUri }, UserAgentApplication.prototype.getCurrentConfiguration = function () { if (!this.config) throw Vt.createNoSetConfigurationError(); return this.config }, UserAgentApplication.prototype.getHash = function (e) { return e.indexOf("#/") > -1 ? e = e.substring(e.indexOf("#/") + 2) : e.indexOf("#") > -1 && (e = e.substring(1)), e }, UserAgentApplication.prototype.getHostFromUri = function (e) { var t = String(e).replace(/^(https?:)\/\//, ""); return t = t.split("/")[0] }, UserAgentApplication.prototype.getTokenType = function (e, t, r) { return r ? Mt.compareAccounts(e, this.getAccount()) ? t.indexOf(this.config.auth.clientId) > -1 ? ur : hr : t.indexOf(this.config.auth.clientId) > -1 ? ur : pr : Mt.compareAccounts(e, this.getAccount()) ? t.indexOf(this.clientId) > -1 ? ur : hr : pr }, UserAgentApplication.prototype.setAccountCache = function (e, t) { var r = e ? this.getAccountId(e) : et.no_account, n = zt.generateAcquireTokenAccountKey(r, t); this.cacheStorage.setItem(n, JSON.stringify(e)) }, UserAgentApplication.prototype.setAuthorityCache = function (e, t) { var r = zt.generateAuthorityKey(e); this.cacheStorage.setItem(r, Mt.CanonicalizeUri(t), this.inCookie) }, UserAgentApplication.prototype.updateCacheEntries = function (e, t, r) { r ? (this.cacheStorage.setItem(et.loginRequest, r, this.inCookie), this.cacheStorage.setItem(et.loginError, ""), this.cacheStorage.setItem(et.stateLogin, e.state, this.inCookie), this.cacheStorage.setItem(et.nonceIdToken, e.nonce, this.inCookie), this.cacheStorage.setItem(et.msalError, ""), this.cacheStorage.setItem(et.msalErrorDescription, "")) : this.setAccountCache(t, e.state), this.setAuthorityCache(e.state, e.authority), this.cacheStorage.setItem(et.nonceIdToken, e.nonce, this.inCookie) }, UserAgentApplication.prototype.getAccountId = function (e) { return Mt.isEmpty(e.homeAccountIdentifier) ? et.no_account : e.homeAccountIdentifier }, UserAgentApplication.prototype.buildIDTokenRequest = function (e) { return { scopes: [this.clientId], authority: this.authority, account: this.getAccount(), extraQueryParameters: e.extraQueryParameters } }, UserAgentApplication.prototype.populateQueryParams = function (e, t, r, n) { var o, i = {}; return t && (t.prompt && (this.validatePromptParameter(t.prompt), r.promptValue = t.prompt), t.claimsRequest && (!function validateClaimsRequest(e) { if (e.claimsRequest) try { JSON.parse(e.claimsRequest) } catch (e) { throw Vt.createClaimsRequestParsingError(e) } }(t), r.claimsValue = t.claimsRequest), Mt.isSSOParam(t) && (i = Mt.constructUnifiedCacheQueryParameter(t, null))), n && (i = Mt.constructUnifiedCacheQueryParameter(null, n)), this.logger.verbose("Calling addHint parameters"), i = this.addHintParameters(e, i, r), t && (o = this.sanitizeEQParams(t)), r.queryParameters = Mt.generateQueryParametersString(i), r.extraQueryParameters = Mt.generateQueryParametersString(o), r }, UserAgentApplication.prototype.validatePromptParameter = function (e) { if (!([ht.LOGIN, ht.SELECT_ACCOUNT, ht.CONSENT, ht.NONE].indexOf(e) >= 0)) throw Vt.createInvalidPromptError(e) }, UserAgentApplication.prototype.sanitizeEQParams = function (e) { var t = e.extraQueryParameters; return t ? (e.claimsRequest && (this.logger.warning("Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both."), delete t[et.claims]), delete t[nt], delete t[ot], t) : null }, function __decorate(e, t, r, n) { var o, i = arguments.length, s = i < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(e, t, r, n); else for (var a = e.length - 1; a >= 0; a--)(o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, r, s) : o(t, r)) || s); return i > 3 && s && Object.defineProperty(t, r, s), s }([gr], UserAgentApplication.prototype, "acquireTokenSilent", null), UserAgentApplication }(); class MsalProvider extends IProvider { get provider() { return this._userAgentApplication } constructor(e) { super(), _defineProperty(this, "_loginType", void 0), _defineProperty(this, "_userAgentApplication", void 0), _defineProperty(this, "scopes", void 0), _defineProperty(this, "clientId", void 0), _defineProperty(this, "ss_requested_scopes_key", "mgt-requested-scopes"), _defineProperty(this, "ss_denied_scopes_key", "mgt-denied-scopes"), this.initProvider(e) } initProvider(t) { this.scopes = void 0 !== t.scopes ? t.scopes : ["user.read"], this._loginType = void 0 !== t.loginType ? t.loginType : e.LoginType.Redirect; let r = (e => { this.tokenReceivedCallback(e) }).bind(this), n = ((e, t) => { this.errorReceivedCallback(e, status) }).bind(this); if (!t.clientId) throw "clientId must be provided"; { let e = t.options || { auth: { clientId: t.clientId } }; e.auth.clientId = t.clientId, e.cache = e.cache || {}, e.cache.cacheLocation = e.cache.cacheLocation || "localStorage", e.cache.storeAuthStateInCookie = e.cache.storeAuthStateInCookie || !0, t.authority && (e.auth.authority = t.authority), this.clientId = t.clientId, this._userAgentApplication = new fr(e), this._userAgentApplication.handleRedirectCallback(r, n) } this.graph = new Graph(this), this.trySilentSignIn() } async trySilentSignIn() { this._userAgentApplication.isCallback(window.location.hash) || (this._userAgentApplication.getAccount() && await this.getAccessToken(null) ? this.setState(e.ProviderState.SignedIn) : this.setState(e.ProviderState.SignedOut)) } async login() { let t = { scopes: this.scopes, prompt: "select_account" }; if (this._loginType === e.LoginType.Popup) { let r = await this._userAgentApplication.loginPopup(t); this.setState(r.account ? e.ProviderState.SignedIn : e.ProviderState.SignedOut) } else this._userAgentApplication.loginRedirect(t) } async logout() { this._userAgentApplication.logout(), this.setState(e.ProviderState.SignedOut) } async getAccessToken(t) { let r, n = t && t.scopes || this.scopes, o = { scopes: n }; try { r = (await this._userAgentApplication.acquireTokenSilent(o)).accessToken } catch (t) { if (console.log(t), this.requiresInteraction(t)) if (this._loginType == e.LoginType.Redirect) this.areScopesDenied(n) || (this.setRequestedScopes(n), this._userAgentApplication.acquireTokenRedirect(o)); else try { r = (await this._userAgentApplication.acquireTokenPopup(o)).accessToken } catch (e) { console.log("getaccesstoken catch2 : " + e) } else this.setState(e.ProviderState.SignedOut) } return r } updateScopes(e) { this.scopes = e } requiresInteraction(e) { return !(!e || !e.errorCode) && (-1 !== e.errorCode.indexOf("consent_required") || -1 !== e.errorCode.indexOf("interaction_required") || -1 !== e.errorCode.indexOf("login_required")) } tokenReceivedCallback(t) { "id_token" == t.tokenType && this.setState(e.ProviderState.SignedIn), this.clearRequestedScopes() } errorReceivedCallback(e, t) { console.log("authError: " + e + " accountState " + t); let r = this.getRequestedScopes(); r && this.addDeniedScopes(r), this.clearRequestedScopes() } setRequestedScopes(e) { e && sessionStorage.setItem(this.ss_requested_scopes_key, JSON.stringify(e)) } getRequestedScopes() { let e = sessionStorage.getItem(this.ss_requested_scopes_key); return e ? JSON.parse(e) : null } clearRequestedScopes() { sessionStorage.removeItem(this.ss_requested_scopes_key) } addDeniedScopes(e) { if (e) { let r = this.getDeniedScopes() || []; var t = (r = r.concat(e)).indexOf("openid"); -1 !== t && r.splice(t, 1), -1 !== (t = r.indexOf("profile")) && r.splice(t, 1), sessionStorage.setItem(this.ss_denied_scopes_key, JSON.stringify(r)) } } getDeniedScopes() { let e = sessionStorage.getItem(this.ss_denied_scopes_key); return e ? JSON.parse(e) : null } areScopesDenied(e) { if (e) { const t = this.getDeniedScopes(); if (t && t.filter(t => -1 !== e.indexOf(t)).length > 0) return !0 } return !1 } } let mr = _decorate([q("mgt-msal-provider")], function (t, r) { return { F: class MgtMsalProvider extends r { constructor(...e) { super(...e), t(this) } }, d: [{ kind: "field", key: "_isInitialized", value: () => !1 }, { kind: "field", decorators: [property({ type: String, attribute: "client-id" })], key: "clientId", value: () => "" }, { kind: "field", decorators: [property({ type: String, attribute: "login-type" })], key: "loginType", value: void 0 }, { kind: "field", decorators: [property()], key: "authority", value: void 0 }, { kind: "field", decorators: [property({ type: String, attribute: "scopes" })], key: "scopes", value: void 0 }, { kind: "method", key: "firstUpdated", value: function firstUpdated(e) { this.validateAuthProps() } }, { kind: "method", key: "validateAuthProps", value: function validateAuthProps() { if (!this._isInitialized && this.clientId) { this._isInitialized = !0; let t = { clientId: this.clientId }; if (this.loginType && this.loginType.length > 1) { let r = this.loginType.toLowerCase(); r = r[0].toUpperCase() + r.slice(1); let n = e.LoginType[r]; t.loginType = n } if (this.authority && (t.authority = this.authority), this.scopes) { let e = this.scopes.split(","); e && e.length > 0 && (t.scopes = e) } Providers.globalProvider = new MsalProvider(t) } } }] } }, LitElement); class TeamsProvider extends MsalProvider { set accessToken(t) { this._accessToken = t, sessionStorage.setItem(this._sessionStorageTokenKey, t), this.setState(t ? e.ProviderState.SignedIn : e.ProviderState.SignedOut) } get accessToken() { return this._accessToken } static async isAvailable() { return !!microsoftTeams } static handleAuth() { if (!this.isAvailable) return void console.error("Make sure you have referenced the Microsoft Teams sdk before using the TeamsProvider"); var t = new URL(window.location.href); let r = sessionStorage.getItem(this._sessionStorageClientIdKey); if (fr.prototype.isCallback(window.location.hash)) return void new MsalProvider({ clientId: r }); if (microsoftTeams.initialize(), r || (r = t.searchParams.get("clientId"), sessionStorage.setItem(this._sessionStorageClientIdKey, r)), !r) return void microsoftTeams.authentication.notifyFailure("no clientId provided"); let n = new MsalProvider({ clientId: r }); const o = async () => { if (n.state === e.ProviderState.SignedOut) n.login(); else if (n.state === e.ProviderState.SignedIn) try { let e = await n.getAccessTokenForScopes(...n.scopes); microsoftTeams.authentication.notifySuccess(e) } catch (e) { microsoftTeams.authentication.notifyFailure(e) } }; n.onStateChanged(o), o() } constructor(t) { super({ clientId: t.clientId, loginType: e.LoginType.Redirect, scopes: t.scopes, options: t.msalOptions }), _defineProperty(this, "scopes", void 0), _defineProperty(this, "_authPopupUrl", void 0), _defineProperty(this, "_accessToken", void 0), _defineProperty(this, "_sessionStorageTokenKey", "mgt-teamsprovider-accesstoken"), TeamsProvider.isAvailable ? (this._authPopupUrl = t.authPopupUrl, microsoftTeams.initialize(), this.accessToken = sessionStorage.getItem(this._sessionStorageTokenKey)) : console.error("Make sure you have referenced the Microsoft Teams sdk before using the TeamsProvider") } async login() { return this.setState(e.ProviderState.Loading), new Promise((e, t) => { microsoftTeams.getContext(r => { let n = new URL(this._authPopupUrl, new URL(window.location.href)); n.searchParams.append("clientId", this.clientId), microsoftTeams.authentication.authenticate({ url: n.href, successCallback: t => { this.accessToken = t, e() }, failureCallback: e => { this.accessToken = null, t() } }) }) }) } async getAccessToken(e) { return this.accessToken } } _defineProperty(TeamsProvider, "_sessionStorageClientIdKey", "msg-teamsprovider-clientId"); let yr = _decorate([q("mgt-teams-provider")], function (e, t) { return { F: class MgtTeamsProvider extends t { constructor(...t) { super(...t), e(this) } }, d: [{ kind: "field", key: "_provider", value: void 0 }, { kind: "field", decorators: [property({ type: String, attribute: "client-id" })], key: "clientId", value: () => "" }, { kind: "field", decorators: [property({ type: String, attribute: "auth-popup-url" })], key: "authPopupUrl", value: () => "" }, { kind: "method", key: "firstUpdated", value: async function firstUpdated(e) { this.validateAuthProps(), await TeamsProvider.isAvailable() && (Providers.globalProvider = this._provider) } }, { kind: "method", key: "validateAuthProps", value: function validateAuthProps() { this.clientId && this.authPopupUrl && (this._provider || (this._provider = new TeamsProvider({ clientId: this.clientId, authPopupUrl: this.authPopupUrl }))) } }] } }, LitElement); class WamProvider extends IProvider { static isAvailable() { return !!window.Windows } get isLoggedIn() { return !!this.accessToken } constructor(e, t) { super(), _defineProperty(this, "graphResource", "https://graph.microsoft.com"), _defineProperty(this, "clientId", void 0), _defineProperty(this, "authority", void 0), _defineProperty(this, "accessToken", void 0), this.clientId = e, this.authority = t || "https://login.microsoftonline.com/common", this.graph = new Graph(this), this.printRedirectUriToConsole() } async login() { if (WamProvider.isAvailable()) { let t = window.Windows.Security.Authentication.Web.Core, r = await t.WebAuthenticationCoreManager.findAccountProviderAsync("https://login.microsoft.com", this.authority); if (!r) return void console.log("no account provider"); let n = new t.WebTokenRequest(r, "", this.clientId); n.properties.insert("resource", this.graphResource); let o = await t.WebAuthenticationCoreManager.requestTokenAsync(n); switch (o.responseStatus) { case t.WebTokenRequestStatus.success: o.responseData[0].webAccount; this.accessToken = o.responseData[0].token, this.setState(this.accessToken ? e.ProviderState.SignedIn : e.ProviderState.SignedOut); break; case t.WebTokenRequestStatus.userCancel: case t.WebTokenRequestStatus.accountSwitch: case t.WebTokenRequestStatus.userInteractionRequired: case t.WebTokenRequestStatus.accountProviderNotAvailable: case t.WebTokenRequestStatus.providerError: console.log(`status ${o.responseStatus}: error code ${o.responseError} | error message ${o.responseError.errorMessage}`) } } } printRedirectUriToConsole() { if (WamProvider.isAvailable()) { let e = `ms-appx-web://Microsoft.AAD.BrokerPlugIn/${window.Windows.Security.Authentication.Web.WebAuthenticationBroker.getCurrentApplicationCallbackUri().host.toUpperCase()}`; console.log("Use the following redirect URI in your AAD application:"), console.log(e) } else console.log("WAM not supported on this platform") } getAccessToken(e) { if (this.isLoggedIn) return Promise.resolve(this.accessToken); throw "Not logged in" } } let kr = _decorate([q("mgt-wam-provider")], function (e, t) { return { F: class MgtWamProvider extends t { constructor(...t) { super(...t), e(this) } }, d: [{ kind: "field", decorators: [property({ attribute: "client-id" })], key: "clientId", value: void 0 }, { kind: "field", decorators: [property({ attribute: "authority" })], key: "authority", value: void 0 }, { kind: "method", key: "firstUpdated", value: function firstUpdated(e) { this.validateAuthProps() } }, { kind: "method", key: "validateAuthProps", value: function validateAuthProps() { void 0 !== this.clientId && (Providers.globalProvider = new WamProvider(this.clientId, this.authority)) } }] } }, LitElement); class MockProvider extends IProvider { constructor(t = !1) { super(), _defineProperty(this, "provider", void 0), _defineProperty(this, "graph", new MockGraph(this)), t ? this.setState(e.ProviderState.SignedIn) : this.setState(e.ProviderState.SignedOut) } async login() { this.setState(e.ProviderState.Loading), await new Promise(e => setTimeout(e, 3e3)), this.setState(e.ProviderState.SignedIn) } async logout() { this.setState(e.ProviderState.Loading), await new Promise(e => setTimeout(e, 3e3)), this.setState(e.ProviderState.SignedOut) } getAccessToken() { return Promise.resolve("{token:https://graph.microsoft.com/}") } } class MockGraph extends Graph { constructor(e) { super(null), _defineProperty(this, "baseUrl", "https://proxy.apisandbox.msdn.microsoft.com/svc?url="), _defineProperty(this, "rootGraphUrl", "https://graph.microsoft.com/"), this.client = Client.initWithMiddleware({ baseUrl: this.baseUrl + escape(this.rootGraphUrl), authProvider: e }) } async getEvents(e, t) { let r = `/me/calendarview?${`startdatetime=${e.toISOString()}`}&${`enddatetime=${t.toISOString()}`}`, n = await this.client.api(escape(r)).get(); return n ? n.value : null } } let vr = _decorate([q("mgt-mock-provider")], function (e, t) { return { F: class MgtMockProvider extends t { constructor() { super(), e(this), Providers.globalProvider = new MockProvider(!0) } }, d: [] } }, LitElement); return e.EventDispatcher = EventDispatcher, e.IProvider = IProvider, e.MgtAgenda = Re, e.MgtBaseComponent = MgtBaseComponent, e.MgtLogin = ee, e.MgtMockProvider = vr, e.MgtMsalProvider = mr, e.MgtPeople = Ue, e.MgtPerson = Y, e.MgtTasks = Ke, e.MgtTeamsProvider = yr, e.MgtWamProvider = kr, e.MsalProvider = MsalProvider, e.Providers = Providers, e.SharePointProvider = class SharePointProvider extends IProvider { get provider() { return this._provider } get isLoggedIn() { return !!this._idToken } constructor(e) { super(), _defineProperty(this, "_idToken", void 0), _defineProperty(this, "_provider", void 0), _defineProperty(this, "context", void 0), _defineProperty(this, "scopes", void 0), _defineProperty(this, "authority", void 0), this.context = e, e.aadTokenProviderFactory.getTokenProvider().then(e => { this._provider = e, this.graph = new Graph(this), this.internalLogin() }) } async internalLogin() { this._idToken = await this.getAccessToken(), this.setState(this._idToken ? e.ProviderState.SignedIn : e.ProviderState.SignedOut) } async getAccessToken() { let e; try { e = await this.provider.getToken("https://graph.microsoft.com") } catch (e) { throw console.log(e), e } return e } updateScopes(e) { this.scopes = e } }, e.SimpleProvider = class SimpleProvider extends IProvider { constructor(e, t, r) { super(), _defineProperty(this, "_getAccessTokenHandler", void 0), _defineProperty(this, "_loginHandler", void 0), _defineProperty(this, "_logoutHandler", void 0), this._getAccessTokenHandler = e, this._loginHandler = t, this._logoutHandler = r, this.graph = new Graph(this) } getAccessToken(e) { return this._getAccessTokenHandler(e.scopes) } login() { return this._loginHandler() } logout() { return this._logoutHandler() } }, e.TeamsProvider = TeamsProvider, e.prepScopes = prepScopes, e
    }({});
  </script>

  <script type="module" src="/build/app.esm.js"></script>
  <script nomodule src="/build/app.js"></script>

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icon/apple-touch-icon.png">
  <link rel="icon" type="image/x-icon" href="/assets/icon/favicon.ico">
  <link rel="manifest" href="/manifest.json">
</head>

<body>

  <app-root></app-root>

</body>

</html>